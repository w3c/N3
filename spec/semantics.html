<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Notation 3 Semantics</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer
    ></script>
    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        specStatus: "CG-DRAFT",
        editors: [
          {
            "name": "Dörthe Arndt",
            "url": "https://iccl.inf.tu-dresden.de/web/D%C3%B6rthe_Arndt/en",
            "company": "TU Dresden",
            "companyURL": "https://tu-dresden.de/",
            "w3cid": 111308,
          },{
            "name": "Pierre-Antoine Champin",
            "url": "http://champin.net/",
            "company": "W3C",
            "companyURL": "https://www.w3.org/",
            "orcid": "0000-0001-7046-4474",
            "w3cid": 42931,
          },
        ],
        github: "w3c/N3",
        shortName: "n3-semantics",
        xref: "web-platform",
	group: "n3-dev",
        format: "markdown",
      };
    </script>
    <!-- Katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          // • rendering keys, e.g.:
          throwOnError : true
        });
    });
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>This is required.</p>
    </section>
    <section id="sotd">
      <p>This is required.</p>
    </section>
    <section class="informative">
      <h2>Introduction</h2>
      <p>This document defines the model-theoretic semantics of
        Notation3 Logic.
        We define the semantics of N3 on an abstract syntax and provide a mapping from explicit N3 Syntax
        to abstract syntax. By doing that we seperate the handling of implicit quantification from the model.
       </p>
       <p>
         <abbr title="Notation3">N3</abbr> is an extension of RDF.
         We use the following concepts from the [[[RDF11-CONCEPTS]]]: <a data-cite="RDF11-CONCEPTS#section-IRIs">IRI</a>,
         <a data-cite="RDF11-CONCEPTS#section-triples">RDF triple</a>, <a
           data-cite="RDF11-CONCEPTS#section-rdf-graph">RDF graph</a>, <a
           data-cite="RDF11-CONCEPTS#section-triples">subject</a>,
         <a data-cite="RDF11-CONCEPTS#section-triples">predicate</a>, <a
           data-cite="RDF11-CONCEPTS#section-triples">object</a>,
          <!--<a data-cite="RDF11-CONCEPTS#dfn-rdf-source">RDF
           source</a>, -->
         <a data-cite="RDF11-CONCEPTS#dfn-node">node</a>, <a data-cite="RDF11-CONCEPTS#dfn-blank-node">blank node</a>,
         and
     <a data-cite="RDF11-CONCEPTS#dfn-literal">literal</a>.
      <!--       <a data-cite="RDF11-CONCEPTS#graph-isomorphism">isomorphic</a>,
         and <a data-cite="RDF11-CONCEPTS#section-generalized-rdf">generalized RDF triples, graphs, and datasets</a>.
       -->
       </p>
    </section>


    <section>
      <h2>Abstract syntax</h2>
      <p class=issue>
        Should this be a normative section, or a reference to a normative section in the "main" spec?
      </p>
      <section class="informative">
        <h3>Motivation</h3>
   <p>Notation3 supports implicit quantification. If blank nodes are used in triples, they stand for implicit existentially
   quantified variables. In case universals (i.e., variables starting with a question mark in the concrete syntax) are used, they stand for implicit
   universally quantified variables. Implicit universal quantification is always global, that is, implicit universal quantification
   always spans over the full graph. Implicit existential quantification is always local, that is, it spans the local graph
   (e.g., if implicit existential quantification occurs in a quoted graph, it spans only the quoted graph).
   To simplify the definitions in this document, we assume all quantification to be explicit
   and introduce an abstract syntax to better express that.
 </p>

  <p>
   In order to help the reader to make a connection between Notation3 concrete syntax and abstract syntax, we will provide example
   translations together with the concepts we introduce. We will provide a formal definition of the mapping at a later point.
</p>

      </section>
    <section class="normative">
        <h3>Terms, Triples and Graphs</h3>

As in the concrete syntax, abstract graphs consist of triples of terms. N3 covers all terms present in
RDF, that is, <a href="https://www.w3.org/TR/rdf11-concepts/#section-Graph-Literal">Literals</a>,
<a href="https://www.w3.org/TR/rdf11-concepts/#section-IRIs">IRIs</a> and
<a href="https://www.w3.org/TR/rdf11-concepts/#section-blank-nodes">blank nodes</a>.
Additionally, we can have universals in N3. As the abstract syntax supports direct
quantification, we represent blank nodes and universals as variables and add their intended quantification seperately.
We thus come to the following concept of atomic terms.
      <p>The set of <dfn>atomic terms</dfn> consists of</p>
      <ul>
        <li>the set $C$ of IRIs,
        <li>the set $L$ of Literals,
        <li>the set $V$ of Variables.
      </ul>
N3 additionally supports the quotation of graphs and treats lists as first-class-citizens. We therefore have an extended
concept of terms:

<p class=issue>
  Should we use the term lists or collections?
  The <a href="https://www.w3.org/TeamSubmission/n3/#lists">team submission</a> uses lists,
  but we use collections elsewhere..
</p>

      <p>A <dfn>term</dfn> can be</p>
      <ul>
        <li>an <a>atomic term</a>,</li>
        <li>a finite (possibly empty) list of <a>terms</a>,</li>
        <li>a <dfn>quoted graph</dfn> $&lt;G&gt;$ where $G$ is a finite <a>graph</a> (see below).</li>
      </ul>
With these terms we can now form triples.
      <p>A <dfn>triple</dfn> is made of</p>
      <ul>
        <li>a term called the <dfn>subject</dfn> of the triple,</li>
        <li>a term called the <dfn>predicate</dfn> of the triple,</li>
        <li>a term called the <dfn>object</dfn> of the triple.</li>
      </ul>
      <div class=issue>
        Maybe we could introduce some blue example box which we would then use for mapping examples?
      </div>

<!-- <p>In the abstract syntax, all quantification is explicit and blank nodes and universals are expressed as variables. Ignoring
quantification, the triple
   <code>_:x :p "text".</code>
becomes $(x, \text{:p}, \text{"literal"})$.</p> -->

<div class=note>
In contrast to RDF, N3 allows all kinds of terms in all positions of a triple. The triple <code>:s _:x :o.</code> are valid in N3.
Even lists or quoted graphs can appear in predicate position of a triple.
</div>
In order to add quantification to the concept of an unordered set of triples (an RDF graph), the concept of a graph in N3 abstract
syntax adds adds information on quantification. In other words, each set of triples comes with information about variables quantified in the graph.
To do so, we define:
      <p>A <dfn>graph</dfn> is a tuple $(U, E, F)$ where</p>
      <ul>
        <li>$U \subseteq V$ is a (possibly empty) set of <dfn class="lint-ignore" data-lt="universally scoped|universal">universally scoped variables</dfn>,</li>
        <li>$E \subseteq V$ is a (possibly empty) set of <dfn class="lint-ignore" data-lt="existentially scoped|existential">existentially scoped variables</dfn>,</li>
        <li>$F$ is a (possibly empty) set of <a>triples</a>.</li>
      </ul>
      <p>A <a>graph</a> $G=(U, E, F)$ is finite if the sets $U$, $E$ and $F$ are finite.</p>
As we will see in the semantics section below, the sets $U$ and $E$ act like quantifiers with variables for the graph and its subgraphs.
We therefore call these sets also <dfn class="lint-ignore" data-lt="quantification set">quantification sets</dfn>.

<p>
To provide some intuition on the correspondence between concrete N3 syntax and abstract N3 syntax, we provide some examples below.
The triples on the left-hand-side of our examples should be considered graphs in the concrete N3 syntax,
and the right-hand side provides the counterpart in abstract N3 syntax.

<ol>
  <li> <code>:socrates :knows _:x.</code> becomes<br>
    <small>$(\{\},\{x\},\{(\text{:socrates}, \text{:knows}, x)\})$</small></li>
  <li> <code>{?x a :Human} => {?x a :Mortal}. </code> becomes <br>
     <small>$(\{x\},\{\},\{(<(\{\},\{\},\{(x, \text{rdf:type}, \text{:Human})\})>,
    \text{log:implies}, <(\{\},\{\},\{(x, \text{rdf:type}, \text{:Mortal})\})>)\})$ </small>
  </li>
  <li> <code>:socrates :says {_:x a :Mortal}.  </code> becomes
    <br><small> $(\{\},\{\},\{(\text{:socrates}, \text{:says}, <(\{\},\{x\},\{(x,\text{rdf:type}, \text{:Mortal} )\})>) \})$</small>
  </li>
  <li> <code>:socrates :says {_:x a :Mortal}. _:y :knows :socrates. </code> becomes
    <br><small> $(\{\},\{y\},\{(\text{:socrates}, \text{:says}, <(\{\},\{x\},\{(x,\text{rdf:type}, \text{:Mortal} )\})>), (y, \text{:knows}, \text{:socrates}) \})$</small>
  </li>
  <li> <code>{?x a :Human} => {?x :hasMother _:y}. </code> becomes <br>
      <small>$(\{x\},\{\},\{(<(\{\},\{\},\{(x, \text{rdf:type}, \text{:Human})\})>,
    \text{log:implies}, <(\{\},\{y\},\{(x, \text{:hasMother}, y)\})>)\})$ </small>
  </li>
  <li> <code>_:y :says {?x a :Mortal}. </code> becomes <br>
      <small>$(\{x\},\{y\},\{(y, \text{:says}, <(\{\},\{\},\{(x, \text{rdf:type}, \text{:Mortal})\})>)$ </small>
  </li>
</ol>
We will re-use these examples in the following sections.
</p>
<!--       <div class=issue>
        Question: RDF does not expect finite graphs. Do we need all graphs to be finite (we should at least expect all cited graphs to be finite, otherwise we cannot quantify over them).
      </div>
-->
      <div class=note>
        In this context, an RDF graph is a graph which does not contain quoted graphs nor lists and for which $U=\emptyset.$
        The blank nodes occurring in the graph would be labeled and stored in $E$.
      </div>
            </section>
      <section>
        <h2>Variables</h2>
For the definitions which follow later in this document, we need to provide some definitions about the variables occurring
in N3 graphs. Here we distinguish between variables occuring directly in a graph an those which are nested. To be able to differentiate,
we introduce the following concept:
        <ul>
          <li>A term is a <dfn>direct constituent</dfn> of
            <ul>
              <li>a list $l$ if it is
                <ul>
                  <li>an element of $l$, or</li>
                  <li>a <a>direct constituent</a> of a list-element of $l$;</li>
                </ul>
              </li>
              <li>a <a>triple</a> $t$ if it is
                <ul>
                  <li>the <a>subject</a>, <a>predicate</a> or <a>object</a> of $t$, or</li>
                  <li>a <a>direct constituent</a> of the <a>subject</a>, <a>predicate</a> or <a>object</a> of $t$;</li>
                </ul>
              </li>
              <li>a <a>graph</a> $G=(U, E, F)$ if it is
                <ul>
                  <li>a <a>direct constituent</a> of a <a>triple</a> $t ∈ F$.</li>
                </ul>
              </li>
            </ul>
            We denote the set of direct constituents of a graph $G$ as $DC(G)$.
          </li>
          <li>A term is a <dfn>constituent</dfn> of a <a>graph</a> $G_1$ if it is either
            <ul>
              <li>a <a>direct constituent</a> of $G_1$, or</li>
              <li>a <a>constituent</a> of graph $G_2$, where the <a>quoted graph</a> $&lt;G_2&gt;$ is a <a>direct constituent</a> of $G_1$.</li>
            </ul>
            We denote the set of constituents of a graph $G$ as $C(G)$.
          </li>
        </ul>

          

          In order to clarify the definition above, we go back to an earlier example (point 3): <br>
          <ul>
            <li>
                <code>:socrates :says {_:x a :Mortal}.  </code> &ndash; abstract syntax:
                <br><small> $(\{\},\{\},\{(\text{:socrates}, \text{:says}, <(\{\},\{x\},\{(x,\text{rdf:type}, \text{:Mortal} )\})>) \})$</small>
                <ul>
                  <li><i>Direct constituents</i>:
                    <small>$\text{:socrates}, \text{:says},  <(\{\},\{x\},\{(x,\text{rdf:type}, \text{:Mortal} )\})>$</small>.
                  </li>
                  <li><i>Constituents</i>:
                    <small>$\text{:socrates}, \text{:says}, <(\{\},\{x\},\{(x,\text{rdf:type}, \text{:Mortal} )\})>, x,\text{rdf:type}, \text{:Mortal}$</small>
                  </li>
                </ul>
              </li>
          </ul>



            <p class=note>Note that the definition makes a difference between <a>graphs</a> and <a>quoted graphs</a>.
              A quoted graph is a direct consituent of the graph it occurs in as a triple component; however, its direct constituents,
              and their direct constituents, are not.
              This difference is crucial for the definitions below: a graph is not the same as a quoted graph.</p>
<p>
With that definition, we now introduce free variables. Free variables are variables which occur directly or nested in the graph but which are not covered by a <a>quantification set</a>.
</p>
            <li>The set $FV$ of <dfn data-lt="free">free variables</dfn> in a term or a set of triples is defined as follows:

              <ul>
                <li>$FV(x) = ∅$ if $x ∈ C ∪ L$,</li>
                <li>$FV(x) = \{x\}$ if $x ∈ V$,</li>
                <li>$FV(x) = FV(x_1) ∪ … ∪ FV(x_n)$ if $x=(x_1 … x_n)$ is a list,</li>
                <li>$FV(x) = FV(s) ∪ FV(p) ∪ FV(o)$ if $x=(s,p,o)$ is a <a>triple</a>,</li>
                <li>$FV(x) = ⋃_{t ∈ x} FV(t)$ if $x$ is a set of <a>triples</a>,</li>
                <li>$FV(x) = FV(F)\setminus(U ∪ E)$ if $x=(U,E,F)$ is a <a>quoted graph</a>,</li>
              </ul>

              For a <a>graph</a> $G=(U,E,F)$ and a variable $v\in V\cap C(G)$:
              <ul>
                <li>we say that $v$  is <a>free</a> in $G$ iff $v\not\in U\cup E$ and there exists $x\in DC(G)$ such that $v\in FV(x)$;</li>
                <li>otherwise we call $v$ <dfn class="lint-ignore" data-lt="scoped variable">scoped</dfn> in $G$;</li>
                <li>we denote the set of variables which are <a>free</a> in $G$ as $FV(G)$.</li>
              </ul>
<p>

Examples:
<ol>
  <li> In <small> $(\{x\},\{y\},\{(x, \text{:knows}, y) \})$</small> all variables are scoped.
  <li> In <small> $(\{\},\{y\},\{(x, \text{:knows}, y) \})$</small> the variable $x$ is free while $y$ is scoped.
  <li> In <small> $(\{\},\{\},\{(y, \text{:says}, <(\{\},\{x\},\{(x,\text{rdf:type}, \text{:Mortal} )\})>) \})$</small>, the variable
    $x$ is scoped while the variable $y$ is free.
<!--  <li> In <small> $(\{\},\{\},\{(\text{x}, \text{:says}, <(\{\},\{x\},\{(x,\text{rdf:type}, \text{:Mortal} )\})>) \})$</small> the
    $x$ is a free variable but it also occurs as a scoped variable in the quoted graph. -->
</ol>
</p>
This enables us to introduce the notion of closed graphs and ground terms.

            <li>A <a>graph</a> $G=(U,E,F)$ is <dfn data-lt="closed graph">closed</dfn> if all variables $v\in C(G)\cap V$ are scoped in $G$.


            <li>A term is <dfn data-lt="ground term">ground</dfn> if it is either
              <ul>
                <li>an IRI,
                <li>a Literal,
                <li>a list of <a>ground</a> terms or the empty list,
                <li>a <a>quoted graph</a> $&lt;G&gt;$ if $G$ is <a>closed</a>.
              </ul>

              <p>We denote the set of <a>ground terms</a> as $T_G$.

              <p>A <a>triple</a> is <a>ground</a> if all of its <a>direct constituents</a> are <a>ground</a>.</p>

              <p>A graph $G=(U,E,F)$ is <a>ground</a> if $E=U=\emptyset$ and all <a>triples</a> in $F$ are <a>ground</a>.</p>
          </li>
        </ul>
        <p class="note">An abstract N3 graph which is constructed from a graph in the direct N3 syntax cannot contain free variables.
        Implicit quantification always comes with a scope and explicit quantification is defined on IRIs which only become variables
        based on their use. The notion of free variables is thus only relevant for quoted graphs and the contexts in which we consider their quoted or unquoted meaning.
        </p>

        <p>An abstract <a>graph</a> $G=(U,E,F)$ can also contain quantified variables $v\in U\cup E$ which do not occur in any <a>triple</a> of $F$. 
          These variables do not contribute to the interpretation of the graph. In order to simplify our considerations for the following sections, 
          we introduce the notion of normalised graphs:</p>

        <p>For each graph $G=(U,E,F)$, we call $G^N=(U\cap (FV(F)), E\cap(FV(F)), F)$ the <dfn data-lt="normalised|normalised graph">normalisation</dfn> of $G$.</p>

        Examples:
        <ol>
          <li>  <small> $(\{x,z\},\{y\},\{(x, \text{:knows}, y) \})^N=(\{x\},\{y\},\{(x, \text{:knows}, y) \})$</small>.
          <li> <small> $(\{x_1, x_2, x_3\},\{y_1, y_2, y_3\},\{(\text{:socrates}, \text{:knows}, \text{:platon}) \})^N=(\{\},\{\},\{(\text{:socrates}, \text{:knows}, \text{:platon}) \})$</small>.
          <li>  <small> $(\{x\},\{y\},\{(y, \text{:says}, <(\{\},\{x\},\{(x,\text{rdf:type}, \text{:Mortal} )\})>) \})^N=$
            $(\{\},\{y\},\{(y, \text{:says}, <(\{\},\{x\},\{(x,\text{rdf:type}, \text{:Mortal} )\})>) \})$</small>.
        <!--  <li> In <small> $(\{\},\{\},\{(\text{x}, \text{:says}, <(\{\},\{x\},\{(x,\text{rdf:type}, \text{:Mortal} )\})>) \})$</small> the
            $x$ is a free variable but it also occurs as a scoped variable in the quoted graph. -->
        </ol>




      
</section>
<section>
  <h2>Isomorphisms</h2>
We would like to define our semantics in a way which assigns the same meaning for structurally identical graphs which only differ in the naming of the variables 
they use. To be able to do so, we first introduce the concept of combined mappings which will be relevant to handle nested graphs with local 
scoping.

<p>For two mappings $M$ and $N$ from terms to terms, we define their <dfn>combination</dfn> as follows:
  
  <ul>
    <li>$M\bullet N(v)=N(v)$ if $v\in dom(N)$</li>
    <li>$M\bullet N(v)=M(v)$ if $v\not\in dom(N)$</li>
  </ul>
</p>
  <div class=note>
  Informally speaking, this definition means that the second mapping "overwrites" the first mapping whenever a constituent is in the domain of both mappings. This is 
  very similar to the behavior of quantifiers in first order logic where the scope of a quantifier is always the set of quantified variables occurring freely in the 
  quantified formula. This similarity is no coincidence. In this document combinations will be mainly used to handle nested scoped variables.
</div>


With combinations of mappings we can define isomorphisms between abstract N3 graphs:

          <p>
          Let $M$ be a bijection between the variables of $V$, we define:
          <ul>
            <li> a graph $G_1$ is isomorphic to $G_2$ under $M$ iff, $G_1^N =(U_1,E_1,F_1)$ and
              $G_2^N=(U_2,E_2,F_2)$ and
              <ul>
                <li> $M(U_1) := \{M(u)|u\in U_1\}= U_2$ and $M(E_1):= \{M(e)|e\in E_1\}= E_2$</li>
                <li> $F_1$ is isomorphic to $F_2$ under $M$</li>
              </ul>
            </li>
            <li> a set of triples $F_1$ is isomorphic under $M$ to a set of triples $F_2$ if there is a bijection $N$ from $F_1$ to $F_2$ such that,
              for each triple $t_1=(s_1, p_1, o_1)\in F_1$,   $N((s_1, p_1, o_1))=(s_2, p_2, o_2)\in F_2$ and $s_1$, $p_1$ and $o_1$ are isomorphic
              under $M$ to $s_2$, $p_2$ and $o_2$ respectively</li>
            <li>a variable $v$ is isomorphic under $M$ to $M(v)$,</li>
            <li> an IRI or Literal is isomorphic to itself,</li>
            <li> a list $l_1=(l_{1,1} \ldots l_{1,n})$ is isomorphic under $M$ to a list
              $l_2=(l_{2,1} \ldots l_{2,m})$ if $m=n$ and for each $0\leq i\leq n$, the element $l_{1,i}$ of $l_1$ is
              isomorphic under $M$ to the corresponding element $l_{2,i}$ of $l_2$,
            </li>
            <li> a quoted graph $< G_1 >$ is isomorphic under $M$ to
              $&lt; G_2 &gt;$
              if for $G_1^{N} =(U_1,E_1,F_1)$ and $G_2^{N}=(U_2,E_2,F_2)$
              there is a bijection $P$ between $U_1 \cup E_1$ and $U_2 \cup E_2$
              such that $G_1$ is isomorphic to $G_2$ under $M\bullet P$.
            </li>
          </ul>

  We call a graph $G_1$ <dfn class="lint-ignore">isomorphic</dfn> to a graph $G_2$, written as $G_1\simeq G_2$, if
  there exists some $M$ such that $G_1$ is isomorphic to $G_2$ under $M$.
</p>

<!--
          <p>Two <a>graphs</a> $G_1$ and $G_2$ are <dfn class="lint-ignore">isomorphic</dfn> (that is, they have an identical form)
            if there is a bijection $M$, called <dfn class="lint-ignore">isomorphism</dfn>, between the atomic constituents of the <a>normalisations</a> $G_1^N=(U_1, E_1, F_1)$
            and $G_2^N=(U_2, E_2, F_2)$ of the two graphs and a bijection $N$ from $F_1$ to $F_2$ such that </p>
            <ul>
              <li>$M$ maps variables to variables
              <li>$M(lit)=lit$ for all literals $lit$ which are <a>constituents</a> of $G_1$,
              <li>$M(iri)=iri$ for all IRIs $iri$ which are <a>constituents</a> of $G_1$,
              <li> $\{M(x)|x\in E_1\}=E_2$,
              <li> $\{M(x)|x\in U_1\}=U_2$,
           <li>$N((l_1,\ldots, l_n) )= (N(l_1),\ldots, N(l_n) )$ for all lists $(l_1,\ldots, l_n)$ which are <a>constituents</a> of $G_1$,

            <li>for each triple $t=( x_1, x_2, x_3 )$ in $F_1$, $N(t)=( y_1, y_2, y_3 )$ is such that
              for all $i \in [1, 2, 3]$<ul>
              <li>if $x_i$ is a <a>quoted graph</a>, then $y_i$ is also a quoted graph, and<ul>
                <li>$x_i = &lt;G_1'&gt;$ with $G_1^{\prime N}= (U_1', E_1', F_1')$,
                <li>$y_i = &lt;G_2'&gt;$ with $G_2^{\prime N}= (U_2', E_2', F_2')$,
                <li>there is a bijection $P$ between $U_1'\cup E_1'$ and $U_2'\cup E_2'$ such that<br>
                   $M\bullet P$ is an isomorphism from $G_1'$ to $G_2'$.
              </ul>
              <li> if $x_i=(l_1, \ldots, l_n)$ is a list, then $y_i=(k_1, \ldots, k_n)$ is also a list and for all $j\in[1,\ldots, n]$
                <ul>
                  <li> if $l_j$ is a a <a>quoted graph</a>, then $k_j$ is also a quoted graph, and<ul>
                    <li>$l_j= &lt;G_{1,j}&gt;$ with $G_{1,j}^{N}= (U_{1,j}, E_{1,j}, F_{1,j})$,
                    <li>$k_j = &lt;G_{2,j}&gt;$ with $G_{2,j}^{N}= (U_{2,j}, E_{2,j}, F_{2,j})$,
                    <li>there is a bijection $P$ between $U_{1,j}\cup E_{1,j}$ and $U_{2,j}\cup E_{2,j}$ such that<br>
                       $M\bullet P$ is an isomorphism from $G_{1,j}$ to $G_{2,j}$.
                  </ul>
                  <li> otherwise $k_j=M(l_j)$
                </ul>
              <li>otherwise $y_i = M(x_i)$,
            </ul>
          </ul>
!-->

          <p class="note">If $G_1$ is isomorphic to $G_2$ then $G_2$ is also isomorphic to $G_1$.</p>

       
            <p>
            Consider the following graphs:
              <ul>
                <li>$G_1$: {<code>_:x :knows :p. :p :says {_:x a :genius}.</code>} &ndash; abstract syntax:<br>
                  <code>({}, {x}, {(x, knows, p), (p, says <{}, {x} {(x, a, genius)}>)})</code>
                </li>
                <li> $G_2:$ {<code>_:y :knows :p. :p :says {_:z a :genius}.</code>} &ndash; abstract syntax:<br>
                  <code>({}, {y}, {(y, knows, p), (p, says <{}, {z} {(z, a, genius)}>)})</code>
                </li>
                <li> $G_3:$ {<code>_:y :knows :p. :p :says {_:x a _:z}.</code>} &ndash; abstract syntax:<br>
                  <code>({}, {y}, {(y, knows, p), (p, says <{}, {x, z} {(x, a, z)}>)})</code>
                </li>
              </ul>
              Then $G_1$ is isomorphic to $G_2$ but not to $G_3$.
            </p>
          </div>


        </section>
    </section>


      <section>
      <h2>Base Semantics</h2>
With the definitions introduced in the previous sections, we are now able to define the semantics of Notation 3 Logic. We do that in two steps: we first 
introduce a base semantics which does not take the meaning of special N3 terms into account. In that sense the base semantics is similar to <a href="https://www.w3.org/TR/rdf11-mt/#simple-interpretations">simple interpretations</a>
for RDF. In a second step, we introduce the N3-interpetation which assigns a special meaning to all predicates in the N3 <a href="../ns/log.html">`log`</a>-namespace.



      <p>A <dfn data-lt="interpretation">basic interpretation</dfn> $I$ is defined by:</p>

      <ul>


        <li>a set $Δ_I$ (<dfn class="lint-ignore">domain</dfn>),
        <li>a mapping $D_I$ (<dfn class="lint-ignore">denotation</dfn>)  from $C ∪ L$ to $Δ_I$,
          such that its restriction to $C$ is a total mapping,
        <li>a mapping $Q_I$ from <a>ground</a> <a>quoted graphs</a> to ground quoted graphs, such that<ul>

            <li>for any quoted graph $&lt;G&gt;$ if $Q_I(&lt;G&gt;)=&lt;H&gt; \implies H \simeq G$</li>
            <li>for two quoted graphs $&lt;G_1&gt;$ and $&lt;G_2&gt;$: $G_1 \simeq G_2\implies Q_I(G_1)=Q_I(G_2)$,</li>
          </ul>
        <li>A subset $EXT_I$ (<dfn class="lint-ignore">extension</dfn>) of $Δ_I^3$, i.e., $Δ_I \times Δ_I \times Δ_I$ as the set of all triples.</li>
      </ul>

      <div class="note">
        <p>This definition is generally "compatible" with RDF simple interpretations, with the following superficial changes:</p>
        <ul>
          <li>IR becomes $Δ_I$,
          <li>IP is assumed, without loss of generality, to be a subset of $Δ_I$,
          <li>IS and IL have been merged in $D_I$,
          <li>IEXT can be derived from $EXT_I$; formally: $IEXT(p) = \{(s,o)|(s,p,o) ∈ EXT_I\}$; conversely: $EXT_I = ⋃_{p∈IP} \{(s,p,o)| (s,o) ∈ IEXT(p\}$.
        </ul>
      </div>

      The basic interpretation maps quoted graphs to an isomorphic copy of itself. 
      <!--- In that sense, 
      quoted graphs are very similar to literals in RDF where . 
      -->
      As a consequence, 
      two non-isomorphic graphs cannot have the same meaning. For the abstract versions of the graphs <code>{_:x :p :o}</code>, <code>{_:y :p :o}</code>
      and <code>{_:x :p :o. _:y :p :o}</code> we thus get:
      <ul>
     <li> $Q_I($&lt;<code>({}, {y}, {(y, :p, :o)})</code>&gt;$)= Q_I($&lt;<code>({}, {x}, {(x, :p, :o)})</code>&gt;$)$
      <li> $Q_I($&lt;<code>({}, {y}, {(y, :p, :o)})</code>&gt;$)\neq Q_I($&lt;<code>({}, {x, y}, {(x, :p, :o),(y, :p, :o) })</code>&gt;$)$
    </ul>

      However, as we will see below, N3 provides mechanisms to "unquote" graphs and to compare them based on the meaning of the formula they quote.
<!---
      <div class="note">
        <p>With the above definition the graphs <code>{_:x :p :o. _:y :p :o}</code> and <code>{_:z :p :o.}</code> do not have the same meaning. 
      </div>

      <div class="note">
        <p>Note that <code>{:s :p :o}</code> and <code>{@forSome :A. :s :p :o.}</code> are isomorphic.</p>

        <p>This has been discussed in the Community group and that is also how EYE and CWM consider them: <a href="http://ppr.cs.dal.ca:3002/n3/editor/s/ctJyZSWM">http://ppr.cs.dal.ca:3002/n3/editor/s/ctJyZSWM</a></p>
      </div>
      -->

     
        <section><h2>Ground graphs</h2>
        We extend the previous definition to interpret <a>ground</a>  graphs:

        <p>Given $I$ a <a>basic interpretation</a>, we recursively define $I(x) =$</p>

        <ul>
          <li>$D_I(x)$ if $x$ is an IRI or a Literal,
          <li>$(I(x_1), I(x_2),..., I(x_n))$ if $x$ is a list $(x_1, x_2, ..., x_n)$ and all $I(x_i)$ are defined,
          <li>$Q_I(x)$ if $x$ is a <a>quoted graph</a>,
          <li>$I(x)=true$ if $x=(s, p ,o)$ is a <a>ground</a> <a>triple</a> and $(I(s), I(p) ,I(o))\in EXT_I$, otherwise $I(x)=false$,
          <li>$I(x)=false$ if $x=F$ is a set of ground triples and $I(t)=false$ for some triple $t\in F$, otherwise $I(x) =true$,
          <li>$I(F)$ if $x=(\emptyset, \emptyset, F)$ is a <a>ground</a> <a>graph</a>
        </ul>

        The definition implies that the empty graph is always true and that the empty list is always mapped to itself. 

      </section>
  



      <section>
        <h2>Graphs with variables</h2>
        In order to introduce the interpretation of graphs containing variables, we rely on a few additional definitions. To better understand the need for these, consider the 
        following example:

        <p>
        <code>?x :says {?x :is :wise}.</code>
      </p>

        which freely translates to "<i>everyone says about himself that he is wise</i>."  In abstract syntax, the formula would be expressed as:

        <p>
        <code><{x}, {}, {(x, :says,</code> &lt; <code>{}, {},  {(x, :is, :wise)}.>}> </code>
        </p>
This formula is interesting because the universally quantified variable appears once as a <a>direct constituent</a> in the triple and once nested. The semantics for ground graphs 
maps direct constituents to not further specified domain elements while ground nested graphs are mapped to an isomorphic version of themselves. If we replace 
the variable $x$ by, for example <code>:bob</code>, we get 
<p>
  &lt;  <code>{}, {}, {(:bob, :says,</code> &lt; <code>{}, {},  {(:bob, :is, :wise)}.</code>&gt;<code>)} </code>&gt;
 </p>
With  the  interpretation:
<p>
  <ul style="list-style-type: none">
<li>$I($<code><{}, {}, {(:bob, :says,</code> &lt; <code>{}, {},  {(:bob, :is, :wise)}.>)}></code>$)$</li>
<li>$=I($<code>(:bob, :says,</code> &lt; <code>{}, {},  {(:bob, :is, :wise)}.>)</code>$)$</li>
</ul>
This interpretation is true if $(D_I($<code>:bob</code>$), D_I($<code>:says</code>$),Q_I($&lt; <code>{}, {},  {(:bob, :is, :wise)}.></code>$)\in EXT_I$. 
</p>

<p>
  Note that the mapping $D_I$ maps the URI <code>:bob</code> directly to a resource of $Δ_I$, 
  while $Q_I$ operates on the quoted graph which contains the URI <code>:bob</code>.
  If we now replace <code>:bob</code> by a variable which is quantified outside of the quoted graph as it was the case in our original example, the first 
  occurence of the variable directly stands for a resource while the meaning of the graph containing the second 
  one depends on the syntactical representation of that resource. 
  We therefore need to extend  <a href=="https://www.w3.org/TR/rdf11-mt/#blank-nodes">RDF's the classical semantic condition for blank nodes</a> and use an so-called 
  assignment which maps variables to a resource and one of its possible term representations  instead of a simple mapping from variables to resources:
</p>
<p>
  Given a <a>basic interpretation</a> $I$ and a set of variables $V$. 
  We call a mapping $A$ from $V$ to $Δ_I\times T_G$ such that $A(v)=(A_1(v),A_2(v))$ and $I(A_2(v))=A_1(v)$ an <dfn>assignment</dfn> for $V$.
  The mapping $A_1$ maps terms to the domain of discourse $Δ_I$. 
  The mapping $A_2$ maps variables to terms, and will be used to determine the meaning of quoted graphs.
</p>

<p>Note that given an interpretation $I$ and two assignments $A$ for a set $V_1$ and $B$ for a set $V_2$ of variables, 
  the <a>combination</a> $A\bullet B$ is again an assignment for $V_1\cup V_2$.</p>
  <!----    </section>

      <section>
        <h2></h2>
      -->
We can consider both values $A_1$ and $A_2$ of an assignment $A(v)=(A_1(v), A_2(v))$ as seperate mappings.  
We extend this kind of function to be applied on graphs:
   
        <p>Let $G=(U,E,F)$ be a graph, $M$ be a mapping from $V$ into a set $S$, and $N = M|_{FV(G)}$ the restriction of $M$ to the <a>free variables</a> of $G$.</p>

        <p>A <dfn class="lint-ignore">total application</dfn> $M^t(G)$ of $M$ is defined as follows:</p>

        <p>$M^t(G) = (U, E, \{ (N^t(s), N^t(p), N^t(o)) | \; (s, p, o) \in F \})$ such that:</p>

        <ul>
          <li>If $x\in FV(G)$ then $N^t(x)=N(x)$
          <li>If $x=(x_1 x_2 \ldots x_n)$ is a list, then $N^t(x)=(N^t(x_1) N^t(x_2) \ldots N^t(x_n))$
          <li>If $x=&lt;H&gt;$ is a quoted graph then $N^t(x) = &lt;N^t(H)&gt;$.
          <li>$N^t(x)=x$ else.
        </ul>
    

 <!--    <section>
        <h2></h2>
--> 
The total application replaces all free variables occurring directly or nested in a graph by the function value. 
 As an example we consider the rule from the beginning of this document, Let $M:\{x,y\}\rightarrow S$ be a mapping such that $M(x)=tom$ and $M(y)=mary$, then we get:

 <p>
    $M^t($<small>$(\{\},\{\},\{(<(\{\},\{\},\{(x, \text{rdf:type}, \text{:Human})\})>,
      \text{log:implies}, <(\{\},\{y\},\{(x, \text{:hasMother}, y)\})>)\})$ </small>$)$
      <br>$=$<small>$(\{\},\{\},\{(<(\{\},\{\},\{(tom, \text{rdf:type}, \text{:Human})\})>,
        \text{log:implies}, <(\{\},\{y\},\{(tom, \text{:hasMother}, y)\})>)\})$ </small>
      </p>
In this example, we replace x by its value because it occurs freely in the graph while y does not get replaced since it is quantified in the nested graph.

<p>
The definition of total applications enables us to define <dfn class="lint-ignore">interpretations with assignment</dfn>:

        <p>For a <a>closed graph</a> $G=(U,E,F)$, a <a>basic interpretation</a> $I$ and an <a>assignment</a> $A$ on the set of variables $U\cup E$ of $G$.</p>

        <p>We define $I[A](x)$ as</p>

        <ul>
          <li> $A_1(x)$ if $x ∈ dom(A)$ and $x$ is a <a>direct constituent</a> of $G$,
          <li> $(I[A](l_1) \ldots I[A](l_n))$ if $x=(l_1 \ldots l_n)$ is a list,
          <li> $Q_I(&lt;A_2^t(H)&gt;)$ if $x=&lt;H&gt;$ is a quoted graph,
          <li> $I(x)$ otherwise.
        </ul>

        <p>For a closed graph $G=(U, E, F)$ and a basic interptetation $I$, we say that the interpretation $I(G)=true$ if for all assignments $A$ for $U$ there exist an assignment $B$ for $E$ such that $I[A\bullet B](F)=true$. We also write that as $I\models G$.</p>
      </p>
        <p class="note">Note that the interpretation of a variable $x$ depends on its position in a graph. In the expression $(x, p, &lt;(∅, ∅, {(x, q, r)})&gt;$, 
          the first  $x$ is interpreted as $A_1(x)$ while the second is interpreted as $A_2(x)$. The connection between these two values is established by the condition that 
        $I(A_2(v))=A_1(v)$.</p>
      

   
       For <dfn class="lint-ignore">assignments and free variables</dfn> we define:
        <p>Let $G=(U,E,F)$ be a <a>graph</a>. We say that $G$ is true under the <a>interpretation</a> $I$ and the <a>assignment</a> $A$ if $I[A]\models G$. That is, for each assignment $A^1$ for the variables in $U$ there exists an assignment $B^1$ for the variables in $E$ such that $I[A\bullet A^1\bullet B^1](F)=true$.</p>
  
      <p>
        This last definition handles all variables occurring freely in a graph as universally quantified.
      </p>
      </section>
      <section>
        <h2>Basic entailment</h2>
The previous definition allows us to introduce the nothion of  basic entailmant:
      
        <p>Let $G$ and $H$ be two graphs, we say that $G$ <dfn data-lt="entailment">entails</dfn> $H$, noted $G ⊨ H$,
        if and only if for every interpretation $I$ such that $I ⊨ G$, $I ⊨ H$.</p>

        <p class="issue">TODO give examples of basic <a>entailment</a> and prove that isomorphic graphs have the same meaning.</p>
      </section>
    </section>
  </section>

    <section>
      <h2>Log-interpretation</h2>

      <p>This section defines a semantic extension enforcing the specific semantics of (some of) the builtins in the <a href="../ns/log.html">`log:`</a> namespace.</p>

      <p>For the definitions below, we assume that the set of literals $L$ contains the two boolean literals `true` and `false`. The literal `true` stands for the quoted graph $&lt;(\emptyset, \emptyset, \emptyset)&gt;$.</p>

      <p>The set of <dfn class="lint-ignore" data-lt="logical predicate">logical predicates</dfn> $LP$ contains the predicate `log:implies`. 
        

      </p>
      <p class="note">This list will be extended whenever we define a "new" logical predicate. The goal here is to cover all (or at least most of) the predicates in the 
        <a href="../ns/log.html">`log:`</a> namespace.</p>.
     </p>
      <p>Let $I$ be an <a>interpretation</a> for a <a>graph</a> $G=(U, E, F)$. Then $G$ is true under <dfn>log-interpretation</dfn> (noted $I\models_{log} G$) if for each <a>assignment</a> $A$ for $U$ there exists an assignment $B$ for $E$ such that:</p>

      <ul>
        <li> $I[A\bullet B](F)=true$, and
        <li> for all triples $(s,p,o)\in F$ with $p\in LP$, $I[A\bullet B]\models_{log}(s,p,o)$.
      </ul>

      <p>We define the meaning of $I[A\bullet B]\models_{log}(s,p,o)$ depending on the concrete $p\in LP$, in the rest of this section.</p>

      <p>We call a graph $G=(U, E, F)$ <dfn>log-free</dfn>, if $p\not\in LP$ for all triples $(s,p,o)\in F$. Note that all <a>log-free</a> graphs which are true under simple <a>interpretation</a> are also true under <a>log-interpretation</a>.</p>

      <section>
        <h2>Constraints for `log:implies`</h2>

          <!-- We call a triple   $t = < G_1 >\texttt{log:implies} < G_2 >$ where  $< G_1=(U_1, E_1, F_1) >$ and $< G_2 = (U_2, E_2, F_2) >$ are quoted graphs an **implication**.
          -->

          <p>If $t = (s, \texttt{log:implies}, o )$ is a triple, then $I[A\bullet B]\models_{log} t$ if</p>

          <ul>
            <li>$I[A\bullet B](s)=&lt; G_1&gt;$ and $I[A\bullet B](o)=&lt;G_2&gt;$ are <a>quoted graphs</a> and $I[A\bullet B]\models_{log} G_2$ holds if $I[A\bullet B]\models_{log} G_1$, or
            <li>$I[A\bullet B](s)=&lt;G_1&gt;$ is a quoted graph and $I[A\bullet B](o)=I(\texttt{false})$ and $I[A\bullet B]\not\models_{log} G_1$, or
            <li>$I[A\bullet B](s)$ is not a quoted graph or $I[A\bullet B](o)$ is neither a quoted graph nor $I(\texttt{false})$.
          </ul>

          <div class="issue">With the above definition, the rule `?x log:implies ?y.` cannot have a model. Since we can replace the consequence by true and by false. So, we can basically derive anything. Alternatively, we could ask for $s=&lt;G_1&gt;$ and $I[A\bullet B](o)=&lt;G_2&gt;$, then we only allow an "open" consequence.</div>

          <div class="note">With the above,
            <pre><code>
:s :p :o.
?x log:implies {:a :b :c}.
            </code></pre>
           yields `:a :b :c.` This is even implemented in EYE, however, if we replace `:s :p :o.`by a rule like `{:c :d :e}=>{:f :g :h}.` The derivation does not work in EYE.
           <a href="http://ppr.cs.dal.ca:3002/n3/editor/s/LfkrfMxO">http://ppr.cs.dal.ca:3002/n3/editor/s/LfkrfMxO</a>
          </div>

          <div class="issue">Think carefully about `_:x log:implies ?y.` and `{:simon :says ?x} log:implies ?x.`. What do we do here? Is that even a problem? Currently that is supported by our semantics.</div>

          <div class="note">PA's tricky question: consider
            <pre><code>
@forAll :X.
:alice a :Student.
{ :X a :Student } => { :X a :Person }.

{ { :alice a :Student } => { :alice a :Person } } => { :test :pass 1 }.
{ @forAll :Z. { :Z a :Student } => { :Z a :Person } } => { :test :pass 2 }.

:X a :Student.

{ :bob a :Student } => { :test :pass 3 }.
{ @forAll :Z. :Z a :Student } => { :test :pass 4 }.
{ @forAll :Z. :Z a :Person } => { :test :pass 5 }.
            </code></pre>
            <p>It seems to me that all tests should pass (according to the semantics).
            However, implementing them correctly looks challenging... (it is not as simple as looking for 'instances' of the rule's body).</p>
            <p>EYE passes all tests. CWM Only passes none. <a href="http://ppr.cs.dal.ca:3002/n3/editor/s/wgG6GZrN">http://ppr.cs.dal.ca:3002/n3/editor/s/wgG6GZrN</a></p>
          </div>

      </section>

    </section>
    <section>
      <h2>Mapping from concrete to abstract syntax</h2>
      <div class="issue"> Not sure where to go with this section, maybe it should also be part of the syntax?</div>
      <p>
        In order to formally define the  mapping between <abbr title="Notation3">N3</abbr> concrete turtle syntax and abstract syntax,
         we first give a more formal
        definition
        of the former. Here, we omit constructs like
        <a href="#polists">predicate and object lists</a>,
        or <a href="#bnodeprplist">blank node property lists</a> as these can be seen as syntactic sugar.
      </p>
      <h3>Concrete Terms and Formulae</h3>
      <p>
        We extend these definitions by introducing the following concepts:
      </p>
      <!--  <p>
          The set of <dfn>N3 symbols</dfn> consists of the set of <a>N3 triple elements</a> and the
          <a>universal variables</a> which are defined below.
        </p> -->
      <p>
        The set of <dfn data-lt="triple element|n3 triple element">N3 triple elements</dfn> consists of the disjoint
        sets of
        <a data-cite="RDF11-CONCEPTS#dfn-iri">IRIs</a>,
        <a data-cite="RDF11-CONCEPTS#dfn-blank-node">blank nodes</a>,
        <a data-cite="RDF11-CONCEPTS#dfn-literal">literals</a>,
        <a href="#dfn-universals">universal variables</a>,
        <a>lists</a>,
        and <a>quoted graphs</a>.
        The set of <a data-cite="RDF11-CONCEPTS#dfn-iri">IRIs</a> conatians the implication sign denoted by the
        <a>builtin</a> <code>log:implies</code>.
        This symbol indicates logical implication and MAY in N3-turtle syntax also be represented using the symbols
        <code>=&gt;</code>.
        The set of <a data-cite="RDF11-CONCEPTS#dfn-literal">literals</a> contains the two boolean literals
        <code>false</code> and <code>true</code>.
        The latter can also be written as <code>{}</code> in N3 turtle syntax.
      </p>
      <p>
        The set of <dfn data-lt="universals">universal variables</dfn> is an arbitrary set of symbols which is
        disjoint
        to all other <a>N3 triple elements</a>.
        In N3-turtle syntax, universal variables are represented by strings starting with a question mark
        <code>?</code>.
      </p>
      <p>
        <dfn>Lists</dfn> are ordered sets consisting of zero or more <a>N3 triple elements</a>.
        We call the list which has no elements the empty list. In N3-turtle syntax,
        we indicate lists by using round brackets <code>()</code>.
        The empty list in <abbr title="Notation3">N3</abbr> is equivalent to the empty list in RDF and can
        thus also be represented using <a href="https://www.w3.org/TR/rdf11-mt/#rdf-interpretations">rdf:nil</a>.
      </p>
      <p>
        <dfn data-lt="quoted graphs|cited formula">Quoted graphs</dfn> (sometimes also called cited formulae) are
        <a>N3 formulae</a> which are surrounded by quoting signs.
        In N3-turtle syntax, we denote these quoting signs as curly brackets <code>{}</code>.
      </p>
      <p>
        An <dfn>N3 triple</dfn> consists of the three components subject, predicate and object, each being an <a>N3
          triple element</a>.
      </p>
      <p>
        An <dfn data-lt="N3 formulae">N3 formula</dfn> is a set of <a>N3 triples</a>.
      </p>

    </section>
  </body>
</html>
<!--=======
<section id='semantics'>
    <h2>Semantics</h2>
    <section id='terms'>





-->
  <!--       <p>Let <code>T</code> be the set of <a>N3 triple elements</a> and <code>dc:T&xrarr;T</code> a function defined
        as
        follows:</p>
      <ul>
        <li><code>dc(c)=dc(c<sub>1</sub>)&cup;...&cup;dc(c<sub>n</sub>)</code>, if
          <code>c=(c<sub>1</sub>... c<sub>n</sub>)</code> is a list,
        </li>
        <li><code>dc(c)={c} </code>else.</li>
      </ul>

      <p>For each <a>N3 triple</a> <code>t= s p o</code> we call the set <code>dc(t)=dc(s)&cup;dc(p)&cup;dc(o)</code>
        the <dfn data-lt="dir-comp">direct components</dfn> of <code>t</code>. For each <a>N3 formula</a> the set of
        its direct components is the union of the direct components of the triples it contains. </p>

   <p>Let <code>T</code> be the set of <a>N3 triple elements</a> and <code>F</code> the set of <a>N3 formula</a>.
        We
        define the function
        <code>nc:T&cup;F&xrarr;T</code> a function defined as follows:
      </p>
      <ul>
        <li><code>nc(e)=nc(e<sub>1</sub>)&cup;...&cup;nc(e<sub>n</sub>)</code>,
          if <code>e=e<sub>1</sub>... e<sub>n</sub></code> is an <a>N3 formula</a> and
          <code>e<sub>1</sub>)&cup;...&cup;nc(e<sub>n</sub></code> are <a>N3 triples</a>,
        </li>
        <li><code>nc(e)=nc(e<sub>1</sub>)&cup;nc(e<sub>2</sub>)&cup;nc(e<sub>3</sub>)</code>,
          if <code>e=e<sub>1</sub> c<sub>2</sub> e<sub>3</sub></code>
          is an <a>N3 triple</a>
          and <code>e<sub>1</sub>, c<sub>2</sub>, e<sub>3</sub></code>
          are <a>N3 triple elements</a>,</li>
        <li><code>nc(e)=nc(e<sub>1</sub>)&cup;...&cup;nc(e<sub>n</sub>)</code>,
          if <code>e=(e<sub>1</sub>... e<sub>n</sub>)</code> is a list,</li>
        <li><code>nc(e)=dc(e<sub>1</sub>)&cup; nc(e<sub>1</sub>)</code>,
          if <code>e={e<sub>1</sub>}</code> is a <a>cited formula</a>,</li>
        <li><code>nc(e)=&empty;</code> else.</li>

      <p>
        For each <a>N3 formula</a> <code>f</code>,
        we call <code>nc(f)</code> the set of <dfn>nested components</dfn>.
      </p>
    </ul>
-->
<!--
      <p>
        We call an <a>N3 formula</a> <dfn>ground</dfn> if its direct and <a>nested components</a> do not contain
        <a>blank nodes</a> nor <a>universal variables</a>.
      </p>
      <p> We call an <a>N3 formula</a> <dfn>closed</dfn> if its direct and <a>nested components</a> do not contain
        <a>universal variables</a> and its <a>direct components</a> do not contain <a>blank nodes</a>.
      </p>
      <p class="EDNOTE">ReSpec complains because <a>ground</a> and <a>closed</a> are defined but not used.</p>
    </section>
-->



  <!--  <section id='sinterpret'>
      <h3>Simple N3 interpretations</h3>

    </section>
    <section id='sneg'>
      <h3>Scoped Negation</h3>

    </section>
  -->
    <!-- <section id='builtins'>
      <h3>N3 Built-ins</h3>
      <p>N3 defines a core set of <dfn>built-ins</dfn> defined
        in a set of vocabularies with defined semantics
        for querying and manipulating <a>N3 documents</a>.
        Built-ins are denoted by a controlled IRI defined in
        one of the core namespaces:</p>
      <ul>
        <li><a href="crypto.html">Crypto</a> –
          <a href="http://www.w3.org/2000/10/swap/crypto#">http://www.w3.org/2000/10/swap/crypto#</a>,
        </li>
        <li><a href="list.html">List</a> –
          <a href="http://www.w3.org/2000/10/swap/list#">http://www.w3.org/2000/10/swap/list#</a>,
        </li>
        <li><a href="log.html">Log</a> –
          <a href="http://www.w3.org/2000/10/swap/log#">http://www.w3.org/2000/10/swap/log#</a>,
        </li>
        <li><a href="math.html">Math</a> –
          <a href="http://www.w3.org/2000/10/swap/math#">http://www.w3.org/2000/10/swap/math#</a>,
        </li>
        <li><a href="string.html">String</a> –
          <a href="http://www.w3.org/2000/10/swap/string#">http://www.w3.org/2000/10/swap/string#</a>, and
        </li>
        <li><a href="time.html">Time</a> –
          <a href="http://www.w3.org/2000/10/swap/time#">http://www.w3.org/2000/10/swap/time#</a>.
        </li>
      </ul>
    </section> -->
  </section>
