<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset='utf-8'>
  <title>Notation3</title>
  <!-- <script async class='remove' src='respec-w3c.js'></script> -->
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>

  <script class='remove'>
    var respecConfig = {
      specStatus: "CG-DRAFT",
      editors: [ // here edit the editors
        {
          name: "William Van Woensel",
          company: "University of Ottawa",
          companyURL: "https://www.uottawa.ca/",
          mailto: "wvanwoen@uottawa.ca"
        },
        {
          name: "DÃ¶rthe Arndt",
          company: "TU Dresden",
          companyURL: "https://tu-dresden.de",
          mailto: "doerthe.arndt@tu-dresden.de"
        },
        {
          name: "Dominik Tomaszuk",
          company: "University of Bialystok",
          companyURL: "https://uwb.edu.pl",
          mailto: "d.tomaszuk@uwb.edu.pl"
        },
        {
          name: "Gregg Kellogg",
          mailto: "gregg@greggkellogg.net"
        }
      ],
      github: {
        repoURL: "https://github.com/w3c/N3",
        branch: "master"
      },
      shortName: "N3",
      group: "cg/n3-dev",
      wgPublicList: "public-n3-dev",
      edDraftURI: "https://w3c.github.io/N3/spec/",
      testSuiteURI: "https://w3c.github.io/N3/tests/",
      localBiblio: {
        "LNG-TAG": {
          title: "Language Subtag Registry",
          href: "http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry",
          publisher: "IANA"
        }
      }
    };
  </script>
  <style>
    table,
    th,
    td {
      border: 1px solid black;
      border-collapse: collapse;
      padding: 5px;
    }

    table.grammar,
    table.grammar th,
    table.grammar td {
      border: none;
      padding: 2px;
      vertical-align: top;
    }

    table.grammar td:nth-child(2) {
      text-align: right;
    }

    table.ex,
    .ex th,
    .ex td {
      border: none;
      padding: 0;
    }

    .ex th {
      text-align: center;
    }

    .ex {
      width: 100%;
    }

    .self-link {
      text-transform: uppercase;
      font-size: 14px;
    }

    pre {
      position: relative;
    }

    .editorlink {
      position: absolute;
      right: 5px;
      top: 5px;
      text-align: right;
      margin-bottom: 25px;
      text-transform: none;
      font-size: 15px;
    }
  </style>
  <script>
    function _esc(s) {
      return s.replace(/&/g, '&amp;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/</g, '&lt;');
    }

    function unComment(doc, content) {
      // perform transformations to make it render and prettier
      return content
        .replace(/\<!--/, '')
        .replace(/--\>/, '')
        .replace(/< !\s*-\s*-/g, '<!--')
        .replace(/-\s*- >/g, '-->')
        .replace(/-\s*-\s*&gt;/g, '--&gt;');
    }

    function updateExample(doc, content) {
      // perform transformations to make it render and prettier
      return _esc(unComment(doc, content));
    }
  </script>

  <script>
    // add editor links to examples
    function loaded() {
      document.respec.ready.then(function () {

        for (let div of document.querySelectorAll("div.example")) {

          let pre = div.querySelector("pre");
          if (pre.className.indexOf("linkeditor") == -1)
            continue;

          let code = pre.innerText.trim();
          let urlEncoded = encodeURIComponent(code);

          let editorUrl = `http://editor.notation3.org/?formula=${urlEncoded}`;
          let openEditorLnk = `<a href="${editorUrl}" target='_blank'>open in editor ðŸš€</a>`;

          let btnDiv = document.createElement("div")
          btnDiv.setAttribute("class", "editorlink");
          btnDiv.innerHTML = openEditorLnk;

          div.querySelector(".marker").appendChild(btnDiv);
        }
      });
    }
  </script>

</head>

<body onload="loaded()">
  <section id='abstract'>
    <p>
      This document defines Notation 3 (also known as <abbr title="Notation3">N3</abbr>), an assertion and logic
      language which is a superset of <abbr title="Resource Description Framework">RDF</abbr>.
    </p>
  </section>
  <section id='sotd'>
    <p>
      This is an initial version of the Notation3 specification.
    </p>
  </section>
  <!--
      How to edit this HTML?
      https://dev.w3.org/2008/video/mediaann/ReSpec.js/documentation.html
      https://github.com/w3c/respec
      -->
  <section id='introduction'>
    <h2>Introduction</h2>
    <p>The Semantic Web represents a vision of online and interconnected knowledge.
      The core building block is a logical formalism called the Resource Description Framework (RDF)
      ([[[RDF11-PRIMER]]]).
      RDF includes logical conjunctions of statements, each describing properties of resources, the properties of the
      objects of those properties, and so on; ultimately, leading to a Knowledge Graph.
      It builds on the fundamental identification mechanism of the Web, i.e., the Uniform Resource Identifier (URI),
      also known as International Resource Identifier (<abbr title="International Resource Identifier">IRI</abbr>), as a
      means to identify any RDF resource, ranging from abstract concepts (the book "Moby Dick") to physical (a paper
      copy of the book "Moby Dick") to electronic objects (an e-book copy of "Moby Dick").
      People have used RDF to build vast quantities of online, connected Knowledge Graphs. The Semantic Web has set the
      stage for decision making within an open environment of interconnected knowledge graphs, as opposed to a closed
      system of locally trusted facts.</p>
    <p>Notation3 Logic, or N3 for short, aims to implement such decision-making abilities in an open web environment
      &mdash; by (a) extending the representational abilities of RDF and (b) allowing access to, operating on,
      and reasoning over online information.
      N3 attempts to walk the line between, on the one hand, ease-of-use by authors and simplicity of reasoning for
      developers; and, on the other hand, extended utility and practicality for building real-world applications.</p>
    <p>The main characteristics of N3 are as follows:</p>
    <ul>
      <li>
        <strong>N3 is a superset of RDF and <abbr title="Terse RDF Triple Language">Turtle</abbr>.</strong>
        Any valid [[[Turtle]]] graph will be valid in N3 as well, meaning that all of Turtle's syntactic sugar is
        available in N3 &mdash; including <a href="#polists">predicate and object lists</a> and unlabeled blank nodes.
        Moreover, <strong><a>collections</a> are first-class citizens</strong> in N3, with an associated set of
        <a>builtins</a> for accessing and manipulating them.
      </li>
      <li>
        <strong>N3 adds declarative programming.</strong>
        N3 allows making statements about the world, which include logical implications with variables
        &mdash; these can loosely be compared to If-Then statements.
        Subsequently, an N3 reasoner can draw inferences from these statements,
        allowing for problem solving, automating decision making, or simply enriching your Knowledge Graph.
      </li>
      <li>
        <strong>N3 supports quoting and describing graphs of statements.</strong>
        A <a>graph term</a> includes a conjunction of quoted statements. It allows expressing where particular
        statements came from, at what time they were stated and by whom (i.e., provenance), and any other description in
        general.
      </li>
      <li>
        <strong>N3 includes builtins for accessing online knowledge.</strong>
        To dynamically retrieve online knowledge for decision making, the <code>log:semantics</code>
        and <code>log:conclusion</code> builtins allow pulling in, parsing, and reasoning
        over logical expressions from online or local sources.
      </li>
      <li>
        <strong>N3 supports a scoped version of negation-as-failure.</strong>
        It can be useful to check whether a <em>specific online source, local graph term, or even the N3 document
          itself</em>,
        at a given point in time, does or does not support a set of facts.
        This is referred to as <em>scoped negation as failure,</em> and is supported by N3's
        <code>log:collectAllIn</code>, <code>log:forAllIn</code>, and <code>log:notIncludes</code> builtin.
      </li>
    </ul>
    <!-- <p class="ednote">Should we highlight <code>log:semantics</code> and <code>log:conclusion</code> that much? They are still causing lots of discussion.
        Maybe we could highlight other useful built-ins instead? Of course, then we would need other constructs for snaf</p> -->
  </section>
  <section id="conformance">
    Sections marked non-normative means they are not considered part of the formal specification; rather,
    they are meant to clarify certain aspects and help with understanding.
  </section>

  <section id='language' class='informative'>
    <h2>Language</h2>
    <p>The aim of this section is to provide an informal overview of the N3 language and its different features. Where
      possible, this section is based on the [[[Turtle]]] specification. More formal definitions will follow in the
      subsequent sections.
    </p>
    <section id='n3doc' class='informative'>
      <h3>N3 document</h3>
      <p>An <dfn>N3 document</dfn> represents an <a>N3 graph</a> in a compact textual form. An <dfn>N3 graph</dfn>
        is a series of <dfn data-lt="statement|triple">N3 statements</dfn>. These are written as <a>triples</a>
        consisting of a
        <a data-cite="RDF11-CONCEPTS#dfn-subject"><dfn>subject</dfn></a>,
        <a data-cite="RDF11-CONCEPTS#dfn-predicate"><dfn>predicate</dfn></a>, and
        <a data-cite="RDF11-CONCEPTS#dfn-object"><dfn>object</dfn></a> resource.
        An <a data-cite="RDF11-CONCEPTS#resources-and-statements"><dfn data-lt="resource|N3 resource">N3
            resource</dfn></a> can be an RDF <a href="#iris">IRI</a>, <a href="#literals">literal</a> or <a
          href="#bnodes">blank node</a>; or an N3 <a>graph term</a>, <a>collection</a>,
        <a href="#n3rules">logical implication</a>, <a>variable</a> or <a>N3 builtin</a>.
        We introduce these types of resources and statements below.
      </p>
      <p>Comments are indicated using a separate '#' and continue until the end of the line.
      </p>
    </section>
    <section id='simpletriples' class='informative'>
      <h4>Simple triples</h4>
      <p>The simplest <a>N3 statement</a> or <a>triple</a> is a sequence of a
        <a data-cite="RDF11-CONCEPTS#dfn-subject">subject</a>,
        <a data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</a>, and
        <a data-cite="RDF11-CONCEPTS#dfn-object">object</a> resource,
        separated by whitespace and terminated by '`.`' after each <a>triple</a>.
      <p>In the example below, three N3 triples highlight the enmity between Spiderman and the Green Goblin and
        lists their human-readable names:</p>
      <!--
          NOTE: there is a data-include attribute
          (https://github.com/w3c/respec/wiki/ReSpec-Editor's-Guide#inclusions--transformations)
          that allows you to directly include a data file here
          -->
      <pre id="basic-triples-example" class="example nohighlight editorl" data-transform="updateExample"><!--
<http://example.org/spiderman> <http://example.org/enemyOf> <http://example.org/green-goblin> .
<http://example.org/spiderman> <http://xmlns.com/foaf/0.1/name> "Spiderman" .
<http://example.org/green-goblin> <http://xmlns.com/foaf/0.1/name> "Green Goblin" . -->
</pre>

      For now, we will asssume that a resource is represented either by an <a>IRI</a> or a <a
        href="#literals">literal</a>.
      In general, one uses an <a>IRI</a> to identify an identifiable entity such as a person, place, or thing &mdash;
      a literal is used for a textual or numerical (i.e., datatype) value, such as name, date, height, and so on.</p>

      <p class="note">There is no inherent order for N3 or RDF triples. The same is true for the relational database
        model, i.e., relational tuples or rows do not have an inherent order. Hence, it is a mistake to associate
        meaning with the order of statements in an N3 document (e.g., assuming that a first listed telephone for
        Spiderman is their landline, and the second one their mobile number).</p>
      <!-- <p class="note">Examples will often be written using newlines and tab spaces for readability. However, generally, only the subjects, predicates and objects need to be separated with a whitespace.</p> -->
      <!-- <pre class="example nohighlight linkeditor">&lt;http://example.org/dt&gt; &lt;http://xmlns.com/foaf/0.1/name&gt; &quot;Dominik Tomaszuk&quot; .</pre> -->
    </section>
    <section id='polists' class='informative'>
      <h4>Predicate and object lists</h4>
      <p>As shown in the above example, the same subject (here, Spiderman) will often be described by several <a>N3
          statements</a>.
        To make these <a>N3 statements</a> less cumbersome to write, one can put a semicolon ("<code>;</code>") at the
        end of an <a>N3 statement</a> to describe the same subject in the subsequent statement:</p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
<http://example.org/spiderman>
    <http://example.org/enemyOf> <http://example.org/green-goblin> ;
    <http://xmlns.com/foaf/0.1/name> "Spiderman" . -->
</pre>
      <!-- <pre class="example nohighlight linkeditor">&lt;http://example.org/dt&gt; &lt;http://xmlns.com/foaf/0.1/firstName&gt; &quot;Dominik&quot; ;
          &lt;http://xmlns.com/foaf/0.1/lastName&gt; &quot;Tomaszuk&quot; .</pre> -->
      <p>Similarly, a predicate (e.g., name) can often list multiple objects for the same subject (e.g., Spiderman).
        This can be written by listing the object values separated by a '<code>,</code>':</p>
      <pre id="object-lists-example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
<http://example.org/spiderman>
    <http://xmlns.com/foaf/0.1/name> "Spiderman", "Peter Parker" . -->
</pre>
      <!-- <pre class="example nohighlight linkeditor">&lt;http://example.org/dt&gt; &lt;http://xmlns.com/foaf/0.1/nick&gt; &quot;Domel&quot;, &quot;Misiek&quot;@pl .</pre> -->
    </section>
    <section id='iris' class='informative'>
      <h3>IRIs</h3>
      <p>An IRI is used to represent an identifiable entity &mdash; such as a person, place, or thing.
        Until now, we have been writing absolute <dfn data-lt="absolute iri|iri">IRIs</dfn> [[RFC3987]] (e.g.,
        <code>http://example.org/Spiderman</code>), which include both the namespace (e.g.,
        <code>http://example.org/</code>) and the local name (e.g., <code>Spiderman</code>).
      </p>

      <p>It is often much easier to write an IRI as a <dfn>prefixed name</dfn> &mdash; e.g., <code>ex:Spiderman</code>,
        which includes a <dfn>prefix label</dfn> (e.g., <code>ex</code>) as a shorthand for the namespace,
        and the <dfn>local name</dfn> (e.g., <code>Spiderman</code>), separated by a colon ("<code>:</code>").
        The `@prefix` directives associate the <a>prefix label</a>
        with a <dfn>namespace IRI</dfn>. A prefixed name is turned into an absolute <a>IRI</a>
        by concatenating the <a>namespace IRI</a> with the <a>local name</a>.
        The following example is equivalent to the <a href="#basic-triples-example">original example</a>:</p>
      <pre id="prefixed-names-example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix ex: <http://example.org/> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

ex:spiderman ex:enemyOf ex:green-goblin ;
    foaf:name "Spiderman" .
ex:green-goblin foaf:name "Green Goblin" . -->
</pre>

      <p class="note">N3 also supports
        case-insensitive `PREFIX` and `BASE` directives, as does Turtle,
        to align the syntax with SPARQL (see <a href="#grammar">grammar</a>).
        These do not have a trailing '.'.
      </p>

      <p>To further simplify prefixed names, one can leave the <a>prefix label</a> empty (e.g., for an often-used
        namespace):</p>
      <pre id="empty-prefix-example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .

:spiderman :enemyOf :green-goblin . -->
</pre>

      <p>One can also write <dfn data-lt="relative iri">relative IRI references</dfn>, e.g.,
        <code>&lt;#Spiderman&gt;</code>.
        A relative IRI reference is <a data-cite="RFC3987#section-6.5">resolved</a>, i.e., turned into an <a>absolute
          IRI</a>, by concatenating the base IRI with the <a>local name</a> (e.g., <code>Spiderman</code>).
        A <dfn>base IRI</dfn> is defined using the `@base` directive.
        For instance, the following is equivalent to the <a href="#empty-prefix-example">prior example</a>:
      </p>
      <pre id="relative-iri-example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@base <http://example.org/> .

<spiderman> <enemyOf> <green-goblin> . -->
</pre>
      <p>Specifics of <a>relative IRI reference</a>
        <a data-cite="RFC3986#section-5.2">resolution</a> are described in
        <a href="#irires" class="sectionRef"></a>.
      </p>

      <p class="note">We recommend listing `@prefix` / `PREFIX` and `@base` / `BASE` declarations
        at the top of an <a>N3 document</a>.
        This is not mandatory, however,
        and they can technically be put anywhere before
        the <a>prefixed name</a> or <a>relative IRI</a>
        that relies on the declaration.
        Subsequent `@prefix` / `PREFIX` directives may "re-map"
        the same <a>prefix label</a> to another <a>namespace IRI</a>.</p>

      <div class="note">
        <p>Prefixed names are a superset of <a href="https://www.w3.org/2001/tag/doc/qnameids.html">XML QNames</a>.
          They differ in that the local name may include:</p>

        <ul>
          <li>leading digits, e.g. `leg:3032571` or `isbn13:9780136019701`</li>
          <li>non leading colons, e.g. `og:video:height`</li>
          <li>reserved character escape sequences, e.g. `wgs:lat\-long`</li>
        </ul>
      </div>

      <!-- <pre class="example nohighlight linkeditor">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
          @prefix : &lt;http://example.org/&gt;

          &lt;http://example.org/doerthe&gt; foaf:knows &lt;http://example.org/dominik&gt; .
          :doerthe foaf:knows :dominik .</pre> -->

      <section id='iriprplist' class='informative'>
        <h4>IRI property lists</h4>
        <p>
          In many cases, an <a>IRI</a> occurs only once as an object, and is then further described as a subject in
          other statements
          (e.g., see a <a href="#prefixed-names-example">prior example</a>).
          The <a href="#iri-prp-list-unfolded">example below</a> illustrates how this may result in difficult-to-read
          code:
          to find descriptions of <a>IRI</a> objects such as `tobey-maguire` or `willem-dafoe`, one must scan the full
          <a>N3 graph</a>,
          as they are only described near the end.
        </p>

        <p>Using the IRI property list syntax, descriptions of these object <a>IRIs</a> can be directly "embedded"
          within the object position:</p>

        <table class="ex">
          <tr>
            <th>Using basic statements:</th>
            <th>Using IRI property lists:</th>
          </tr>
          <tr>
            <td style="max-width:40vw">
              <pre id="iri-prp-list-unfolded" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .
@prefix foaf:<http://xmlns.com/foaf/0.1/>.
    
:spiderman 
:enemyOf :green-goblin ;
  :portrayedBy :tobey-maguire .
    
:green-goblin 
  :portrayedBy :willem-dafoe .

:tobey-maguire a :Actor .
:willem-dafoe a :Actor .
 -->
</pre>
            </td>
            <td style="max-width:40vw">
              <pre id="iri-prp-list" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .
@prefix foaf:<http://xmlns.com/foaf/0.1/>.
    
:spiderman 
  :enemyOf 
    [ id :green-goblin 
      :portrayedBy [ id :willem-dafoe
        a :Actor 
      ]
    ] ;
  :portrayedBy [ id :tobey-maguire
      a :Actor
  ] . -->
</pre>
            </td>
          </tr>
        </table>

        <p>IRI property lists build on the <a href="#polists">predicate object list</a> syntax to group statements about
          <a>IRIs</a>.
          One can use <a href="#object-lists-example">objects lists</a> in this syntax as well.
        </p>

        <p class="note">See also the <a href="#bnodeprplist">blank node property list</a> syntax.</p>
        <p class="note">See <a data-cite="JSON-LD11#embedding">embedding</a> in [[JSON-LD11]] for a discussion of a
          similar feature in
          another format.</p>

      </section>

    </section>

    <section id='literals' class='informative'>
      <h3>Literals</h3>
      <p>Literals are used to represent a textual or numerical (i.e., datatype) value, such as name,
        date, height, and so on. Numbers (integers, decimals, and doubles) are simply represented using their
        numerical value, and booleans are represented using <code>true</code> or <code>false</code>:</p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/elements> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

<http://en.wikipedia.org/wiki/Helium>
  :atomicNumber 2 ;               # xsd:integer
  :atomicMass 4.002602 ;          # xsd:decimal
  :specificGravity 1.663E-4 ;     # xsd:double
  :isNobleGas true ;              # xsd:boolean
  rdfs:label "Helium" .           # xsd:string -->
</pre>
      <p>For details on numerical syntaxes (e.g., decimals, doubles), we refer to the <a data-cite="TURTLE#abbrev">RDF
          1.1: Turtle (Section 2.5.2)</a> specification.</p>
      <p>Other literals, such as strings, but also dates, binary, octal or hex code, XML or JSON code, or other types of
        numbers (e.g., shorts), need to be written as <b>datatyped literals</b>. These are represented as a string,
        followed by the `^^` symbol and the corresponding <dfn data-cite="XMLSCHEMA11-2#built-in-datatypes">datatype
          IRI</dfn>.
        (`xsd:string` is the datatype IRI for strings; this is the default and can be omitted, in which case the `^^`
        MUST
        also be omitted; in other words, `"example"^^` is not a valid datatyped literal). For instance:</p>

      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/> .

:spiderman
  :birthDate "2001-08-10"^^xsd:date . -->
</pre>

      The literal's <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> will include the characters between
      the delimiter quotes (e.g., <code>2001-08-10</code>).

      <p>The language of the string literal can be indicated using the <code>@</code> symbol and the corresponding
        language tag (as defined in [[BCP47]] &mdash; find the registry in [[LNG-TAG]]). For instance:</p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix : <http://example.org/> .

:spiderman foaf:name "Spiderman"@en ,
  "Hombre AraÃ±a"@es , "Homme AraignÃ©e"@fr . -->
</pre>
      <p>The reading direction can be described together with the language [[BCP47]], using the <code>i18n</code>
        namespace:</p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix i18n: <https://www.w3.org/ns/i18n#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix : <http://example.org/> .

:spiderman foaf:name "Ø§Ù„Ø±Ø¬Ù„ Ø§Ù„Ø¹Ù†ÙƒØ¨ÙˆØª"^^i18n:ar-EG_rtl . -->
</pre>

      <p class="note">If no <a>datatype IRI</a> or language tag is given, the datatype <code>xsd:string</code> will be
        assumed.
        In case a language tag is given or a <code>i18n</code> "datatype" is used, the datatype
        <code>rdf:langString</code> is inferred.
        It is not possible to specify both a <a>datatype IRI</a> and a language tag.</p>

      <p class="note">There are also other ways to describe the language tag and base direction of RDF literals, see <a
          href="#compoundliteral">Compound literals<a>.
            Please note that these various ways are still in flux,
            see the <a href="https://github.com/w3c/rdf-star-wg/blob/main/docs/text-direction.md">"text direction"</a>
            discussions in the RDF-star working group.</p>

      <p class="note">Integers, decimals, doubles, and booleans may also be written as string literals with the
        appropriate <a>datatype IRI</a> (e.g., `"8"^^xsd:integer` or `"true"^^xsd:boolean`).
      </p>

      <p>In case the the string literal itself contains the string delimiter (e.g., double quotes), or includes
        newlines, other string delimiters can be used, i.e., single quotes or compound delimiters <code>"""</code> or
        <code>'''</code>.
        Alternatively, one can also use a '<code>\</code>' for escaping the delimiter each time it occurs within a
        string literal.
        For instance:
      </p>
      <pre id="string-literal-example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/> .

:spiderman rdfs:label 
  '"Bitten" by a radioactive spider.' ,
  "\"Bitten\" by a radioactive spider." ,
  """'Bitten' by "what"?
  A radioactive spider!""" . -->
</pre>

      <p>The escape symbol '<code>\</code>' (<span class="codepoint">U+005C</span>) may only appear in a
        string literal as part of an <a href="#escseq">escape sequence</a>. Other restrictions within string literals
        depend on the delimiter:</p>
      <ul>
        <li>Literals delimited by <code>'</code> may not contain the characters
          <code>'</code>, <code title="LINE FEED"><sub>LF</sub></code> (<span class="codepoint">U+000A</span>), or <code
            title="CARRIAGE RETURN"><sub>CR</sub></code> (<span class="codepoint">U+000D</span>).
        </li>
        <li>Literals delimited by <code>&quot;</code> may not contain the characters <code>&quot;</code>, <code
            title="LINE FEED"><sub>LF</sub></code>, or <code title="CARRIAGE RETURN"><sub>CR</sub></code>.
        </li>
        <li>Literals delimited by <code>'''</code> may not contain the sequence of characters <code>'''</code>.
        </li>
        <li>Literals delimited by <code>&quot;&quot;&quot;</code> may not contain the sequence of characters
          <code>&quot;&quot;&quot;</code>.
        </li>
      </ul>
      <!-- <pre class="example nohighlight linkeditor">@prefix : &lt;http://example.org/vocab/&gt; .
          @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
          @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

          _:x rdfs:comment &quot;This is an example.&quot;^^xsd:string . # literal with XML Schema string datatype
          _:x rdfs:comment &quot;This is an example.&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; . # same as above
          _:x rdfs:comment &quot;This is an example.&quot; .  # same again
          _:x rdfs:comment &quot;To jest przykÅ‚ad.&quot;@pl . # literal with a language tag
          _:x rdfs:comment 'Ceci est un exemple.'@fr . # literal delimited by single quote
          _:x rdfs:comment '''This # literal with embedded new lines
          is
          an example.''' .
          </pre> -->
    </section>
    <section id='bnodes' class='informative'>
      <h3>Blank Nodes</h3>
      <p>When describing resources in RDF, you can run into the following situations:</p>
      <ul>
        <li>
          It is not worth minting a new <a>IRI</a> for the resource, as it is unlikely that other <a>N3 graphs</a>
          will refer to it.
        </li>
        <li>
          There likely already exists an <a>IRI</a> for the resource, and we don't want to do an extensive search to
          find out what it is.
        </li>
      </ul>
      <p>Instead, you can use <dfn>blank nodes</dfn> to talk about resources.
        They are existential variables; that is, they state the existence of a thing without identifying it.
        <a>Blank nodes</a> can be represented in several ways, as described below.
        For details, please refer to ([[[RDF11-CONCEPTS]]]).
      </p>
      <section id='bnodeids' class='informative'>
        <h4>Blank node identifiers</h4>
        <p>A <a>blank node</a> can be represented by a <dfn data-cite="RDF11-CONCEPTS#dfn-blank-node-identifier">blank
            node identifier</dfn>, which is unique within the <a>N3 graph</a>, expressed as <code>_:someLabel</code>.
          Then, we use this identifier within our <a>N3 graph</a> to describe the corresponding resource, same as with
          an <a>IRI</a>.
        <p>For instance, this <a data-cite="RDF11-PRIMER#section-blank-node">example</a> shows that the Mona Lisa
          has an unidentified tree in its background. We don't want to concretely identify this tree, but we do want to
          describe it &mdash;
          such as the painting it is in, and the type of tree:
        <p>
        <pre id="mona-lisa-bnode-id" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix ex: <http://example.org/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

ex:mona_lisa_painting ex:portrays _:someTree .
_:someTree rdf:type ex:CypressTree . -->
</pre>
        <p>In this example, we minted a <a>blank node identifier</a> <code>_:someTree</code> to represent the resource
          that
          we want to describe. Note that this identifier is only usable within our local <a>N3 graph</a> &mdash;
          if you want other <a>N3 graphs</a> to describe it, you should represent it using an <a>IRI</a>.</p>
      </section>
      <section id='bnodeprplist' class='informative'>
        <h4>Blank node property lists</h4>
        <p>Using a <a>blank node identifier</a> requires introducing a new identifier for each <a>blank node</a>.
          In many cases, however, a blank node occurs only once as an object,
          and is then further described as a subject in other statements, such as in the <a
            href="#mona-lisa-bnode-id">prior example</a>.
          In those cases, a more convenient syntax can be used.</p>
        <p>
          The <a href="#address-bnode-prp-list-simplified">example below</a> shows a more elaborate example:
          identifiers `_:a` and `_:t` are used as object in only one statement,
          and are then described as subject in other statements.
          Using the blank node property list syntax, these cases can be represented as follows:</p>

        <table class="ex">
          <tr>
            <th>Using blank node identifiers:</th>
            <th>Using blank node property lists:</th>
          </tr>
          <tr>
            <td style="max-width:40vw">
              <pre id="address-bnode-prp-list-simplified" class="example nohighlight linkeditor"
                data-transform="updateExample"><!--
@prefix ex: <http://example.org/> .
ex:john ex:address _:a .
_:a ex:street "Evergreen Terrace" .
_:a ex:number 742 .
_:a ex:town _:t .
_:t ex:name "Springfield" .
 -->
</pre>
            </td>
            <td style="max-width:40vw">
              <pre id="address-bnode-prp-list" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix ex: <http://example.org/> .

ex:john ex:address [
  ex:street "Evergreen Terrace" ;
  ex:number 742 ;
  ex:town [ ex:name "Springfield" ]
] . -->
</pre>
            </td>
          </tr>
        </table>

        <p class="note">See also the <a href="#iriprplist">IRI property list</a> syntax.
          However, note that you cannot use that syntax (`id` keyword) with blank node identifiers.</p>

        <p>The "blank node property list" syntax is especially useful in cases where a blank node occurs only once as an
          object.
          When the blank node occurs several times as an object, such as when describing multiple people with the same
          address,
          it is better to use blank node identifiers. For instance:

        <pre id="address-multiple-people" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix ex: <http://example.org/> .

ex:john ex:address _:a .
ex:sally ex:address _:a .
_:a ex:street "Evergreen Terrace" .
_:a ex:number 742 .
_:a ex:town [ ex:name "Springfield" ] . -->
</pre>
        <p>We can still use the blank node property list syntax for describing the town,
          as this blank node still only occurs once as object.</p>
        </p>
      </section>

      <section id="bnode-use-cases" class='informative'>
        <h4>Blank node use cases</h4>
        <p>Below, we summarize typical use cases where <a>blank nodes</a> are used to describe resources.</p>
        <p><strong>Unknown resources</strong>: we might <a data-cite="RDF11-PRIMER#section-blank-node">want to state</a>
          that the Mona Lisa painting has in its background an unidentified tree, which we know to be a cypress tree. We
          could mint an <a>IRI</a> such as "mona-lisa-cypress-tree", but we feel that would be redundant &mdash; we
          simply want to describe the tree, such as the painting it is in, and the type of tree. We're not particularly
          interested in allowing other <a>N3 graphs</a> to refer to the tree. Moreover, there may already exist an
          <a>IRI</a> for that particular tree, and we don't want to mint another <a>IRI</a> to refer to the same tree
          (nor do we want to lookup this existing <a>IRI</a>).
        </p>
        <p><strong>Composite information</strong>: when describing composite pieces of information, such as street
          addresses,
          telephone numbers and dates, it is often unlikely that anyone outside this <a>N3 graph</a> would need to refer
          to this address or its pieces.
          Hence, it would be redundant to mint an <a>IRI</a> just for the purpose of structuring this information.
          Instead, one can use a <a data-lt="blank node">blank node</a> to connect the
          "composed" pieces of information, e.g., the street address, to its composite values, e.g., street name,
          number,
          and city, as shown in <a href="#address-bnode-prp-list">this example</a>.</p>
        <p><strong>N-ary relations</strong>: <a>blank nodes</a> are a convenient way to represent <a
            href="#nary-binary-rel">n-ary relations in N3</a>.</p>
        <!--
            <pre class="example nohighlight linkeditor">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

            _:doerthe foaf:knows _:dominik .
            _:dominik foaf:knows [ foaf:firstName &quot;William&quot; ].</pre>
            -->
        <p><strong>Compound literal</strong>: to represent language-tagged strings,
          see section <a href="#compoundliteral">Compound literals</a>.</p>
      </section>
    </section>
    <section id='collections' class='informative'>
      <h3>Collections</h3>
      <p>We often need to describe ordered collections of things, e.g., a book written by several authors,
        listing the students in a course, or the software modules within a package. N3 supports <dfn
          data-lt="n3 collection|n3 list|list">collections</dfn> as first-class citizens
        to represent ordered collections of resources enclosed by parentheses
        ("<code>(</code> <code>)</code>").
        The contained resources are called <dfn data-lt="collection member">members</dfn>.</p>
      <p>For instance:</p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .

:description_logic_handbook a :Book ;
  :author ( :deborah :daniele :peter) . -->
</pre>
      <p>This states that the value of the author property is the <em>collection resource</em>.</p>
      <p class="note"><strong>Any additional meaning is not given by the N3 semantics</strong>.
        For instance, this example does not imply that each <a>member</a> (e.g.,
        <code>:deborah</code>) can be considered as a value of the author property &mdash; i.e., the author property
        does not "distribute" across the <a>members</a>.
        For that matter, it is also not implied that the first <a>member</a> put the most effort into the book.
        Any additional meaning, such as each member being an author of the book,
        and the ordering reflecting the authors' effort, would always be application-specific.<br />
        <br />
        In general, to implement such application-specific meanings, N3 rules could be used.
        Alternatively, one could use an <a href="#object-lists-example">object list</a>
        to explicitly state that each of these resources are authors of the book: <br />
        &nbsp;&nbsp;&nbsp;&nbsp;`:description_logic_handbook :author :deborah, :daniele, :peter .`<br />
        However, since RDF (and thus N3) statements do not have an inherent order, this example loses meaning
        as we no longer know who can be considered the "first" author.
      </p>

      <p class="note">To an extent, an N3 collection <a href="#semantics">is equivalent to</a> the more verbose <a
          data-cite="rdf11-mt#rdf-collections">RDF Collection vocabulary</a>.
        We refer to the <a href="https://www.w3.org/TeamSubmission/n3/#lists">original N3 submission</a>
        for the additional axioms needed for this equivalency.
      </p>

      <p>In N3, collections may occur as subjects, predicates or objects in a statement. For instance:</p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .

(:Fred :Wilma :Dino) :approved :resolution123 . -->
</pre>
      <p>Or even:</p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .

(:Fred :Wilma :Dino) (:read :liked :approved) (:resolution1 :resolution2 :resolution3) . -->
</pre>
      <p>As before: any meaning that goes beyond the fact that 3 <a>collection</a> resources are involved in this
        statement, would be application-specific.</p>
      <!-- &mdash; for instance, that the predicate
        <code>(:read :liked :approved)</code> means that the subject <a>collection</a> did all those things for all
        members in the object <a>collection</a>. -->
      <!--
          <pre class="example nohighlight linkeditor">
          @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
          _:n3
            foaf:member (
              _:doerthe
              _:william
              _:dominik
            ).</pre>
              -->
    </section>
    <section id='graphterms' class='informative'>
      <h3>Graph Terms</h3>
      <p>
        It is often useful to attach metadata to groups of triples &mdash;
        to give the provenance, context, or version of the information, our opinion on the matter, and so on.
        We can use <dfn>graph terms</dfn> to quote RDF graphs, and then describe the <a>graph term</a> using <a>N3
          statements</a>. For instance:
      </p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix dc: <http://purl.org/dc/terms/> .
@prefix : <http://example.org/> .

{ :cervantes dc:wrote :moby_dick } :opinion :lie ;
  :retrievedFrom <http://lies_r_us.com> ;
  :retrievedAt "2020-07-12T09:01:33"^^xsd:dateTime . -->
</pre>
      <p>
        Essentially, a <a>graph term</a> represents an occurrence of an RDF graph &mdash; i.e., a <em>quoting</em> or
        <em>citing</em> of the graph. Importantly, a <a>graph term</a> does not assert the contents of the RDF
        graph as being true (e.g., <code>:cervantes dc:wrote :moby_dick</code>). In fact, the <a>graph term</a> is <a
          href="#semantics">interpreted as a resource on its own</a>.
      </p>
      <p>As with <a>collections</a>, <a>graph terms</a> can be used in any position in an <a>N3 statement</a>.</p>
      <p>As they represent a <i>quoting</i> of RDF graphs, <a>graph terms</a> are not "referentially transparent". For
        instance:</p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .

:LoisLane :believes { :Superman :can :fly } . -->
</pre>
      <p>This <a>N3 statement</a> states that Lois Lane believes that Superman can fly.
        Even if it is known that <code>:Superman</code> is the same as <code>:ClarkKent</code>, one cannot infer from
        this that Lois Lane believes that <code>:ClarkKent</code> can fly.
        Indeed, this is an accurate depiction of Lois Lane's statement at the time &mdash;
        as she did not know that Superman is Clark Kent at that point,
        she would certainly not be saying that Clark Kent can fly.</p>
    </section>

    <section id='n3rules' class='informative'>
      <h3>N3 Rules</h3>

      <p>N3 supports declarative programming by allowing to make statements about the world,
        including logical implications, or <dfn data-lt="logical implication|N3 rule">N3 rules</dfn>, which can be
        loosely compared to If-Then statements.
        Based on the N3 semantics, so-called inferences can be drawn from these statements.
        An N3 reasoner can draw such inferences automatically, to support
        problem solving, decision making, or simply enriching your Knowledge Graph.</p>

      <p>For instance, the following is an <a>N3 rule</a>:</p>

      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix : <http://example.org/>.

{ :weather a :Raining
} => {
  :weather a :Cloudy
} . -->
</pre>

      <p>
        This is a logical construct, such as a conjunction (AND) and disjunction (OR).
        Stating such a <a>logical implication</a> means that, in case the <dfn data-lt="premise|rule premise">rule
          premise</dfn> is true (it is raining),
        the <dfn data-lt="conclusion|rule conclusion">rule conclusion</dfn> must be true as well (it is cloudy).
        If this is not the case &mdash; raining does not imply that it is cloudy
        &mdash; the implication would be false.
        However, this is not possible, since all statements in N3 (and RDF) are true by default.
      </p>

      <p>
        Hence, when the <a>premise</a> holds, then we can safely infer the <a>conclusion</a>.
        This is also referred to as <dfn data-lt="fire|firing">firing</dfn> the rule.
        For the example above, if we state `:weather a :Raining`, then we can safely infer `:weater a :Cloudy`.
      </p>

      <p class="note">
        An <a>N3 rule</a> is actually a N3 statement, where the <a>subject</a> and <a>object</a> constitute <a>graph
          terms</a>,
        and the <a>predicate</a> is `log:implies`, with symbol `=&gt;` as syntactic sugar.
        <!-- For backward chaining rules (see <a href="n3rulechaining">rule chaining</a>), 
          the predicate is `log:impliedBy`, with symbol `&lt;=` as syntactic sugar. -->
        <!-- In fact, these predicates themselves are <a>N3 builtins</a>. -->
      </p>

      <section id='n3rulevars' class='informative'>
        <h3>Rule Variables</h3>

        <p><a>N3 rules</a> are more useful when they include <dfn>variables</dfn>.
          For instance, the following includes a universal variable (prefixed by `?`):
        </p>
        <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix : <http://example.org/>.

:spiderman a :SuperHero .

{ ?x a :SuperHero
} => {
  ?x a :Imaginary
} . -->
</pre>

        <p>
          This states that the <a>N3 rule</a> is true for each value of variable `?x`:
          when the <a>premise</a> is true for a particular value for `?x`
          (being a super hero),
          then the <a>conclusion</a> must be true for that value as well (being imaginary).
          For the example above, the <a>premise</a> is true for value `:spiderman`,
          meaning we can infer the <a>conclusion</a> for that value, i.e.,
          `:spiderman a :Imaginary`.
        </p>
        <p class="note">
          More technically, the triples in the <a>rule premise</a>
          (e.g., `?x a :SuperHero`) can be seen as <dfn><a data-cite="SPARQL11-QUERY#QSynTriples">triple
              patterns</a></dfn>.
          In order to <a>fire</a> the rule, these triple patterns are matched to concrete triples
          in the <a>N3 document</a>.
          If a match is successful, concrete resources from the matching triple (e.g., `:spiderman`)
          are bound to the triple pattern's <a>variables</a> (e.g., `?x`).
          These bound variable values are then used in the inferred conclusion (e.g., `:spiderman a :Imaginary`).
        </p>
      </section>

      <section id='n3rulechaining' class='informative'>
        <h3>Rule Chaining</h3>

        <p>In practice, a pivotal feature is that <a>N3 rules</a> can be "chained":
          a rule can depend on the results of other rules. For example:
        </p>

        <pre id="chaining_example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix : <http://example.org/>.
            
:spiderman a :WebSlinger .
:44th :traffic :heavy .
            
{ ?slinger a :WebSlinger } => { ?slinger :locomotion :flying } .

{ ?heli a :Helicopter } => { ?heli :locomotion :flying  } .

{ ?flyer :locomotion :flying . ?street :traffic :heavy } 
  =>  { ?street :suitable-observer ?flyer } . -->
</pre>

        <p>
          The third <a>N3 rule</a> relies on the <a>rule conclusion</a> (`:locomotion`) of the first two rules:
          if one of those rules <a>fire</a>, i.e., inferring a flying locomotion for a resource,
          then the third rule would <a>fire</a> as well, i.e., inferring that the resource
          would be a suitable observer for a street with heavy traffic.
          <!-- Hence the term "chaining"; rules 1 and 2 each form a chain with rule 3. -->
          This allows for a modularization of N3 code:
          the first two rules separately decide when something supports a flying locomotion;
          the third rule determines what the general effects of flying locomotion are.
        </p>

        <p class="note">
          Variable names only have to be unique within a rule, and not across rules.
          For instance, in the <a href="#chaining_example">prior example</a>,
          we simply could have named every variable `?x`.
          As with general coding practices, it is typically a good idea to give variables a
          meaningful name.
        </p>
        </p>

        <p>
          An N3 reasoner, which can draw inferences from <a>N3 rules</a>,
          can operate in forward chaining, backward chaining, or some hybrid mode.
          An <a>N3 rule</a> can also indicate which mode should be used,
          by using the appropriate predicate.
          Up until now, we have used `=&gt;`, which is syntactic sugar for `log:implies` and
          directs the reasoner to operate in forward chaining mode.
          The `&lt;=` predicate, which is syntactic sugar for `log:impliedBy`, indicates a backward chaining mode.
        </p>
        <p>
          For instance, the following is equivalent to the <a href="#chaining_example">prior example</a>
          and combines forward and backward chaining:
        <pre id="backward_chaining_example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix : <http://example.org/>.
            
:spiderman a :WebSlinger .
:44th :traffic :heavy .

{ ?slinger :locomotion :flying } <= { ?slinger a :WebSlinger } .

{ ?heli :locomotion :flying } <= { ?heli a :Helicopter } .

{ ?flyer :locomotion :flying . ?street :traffic :heavy } 
  =>  { ?street :suitable-observer ?flyer } . -->
</pre>
        </p>

        <p>
          In a nutshell, forward reasoning presents a bottom-up approach:
          starting from a set of initial and inferred statements,
          a reasoner will <a>fire</a> any N3 rule where the <a>premise</a> holds,
          each time adding the inferences to the set, until no more N3 rules can be fired.
          Backward chaining is a top-down approach: given a query, such as `?x :locomotion :flying`,
          the reasoner will search for any rules with <a>conclusions</a> that may satisfy the query (e.g., first and
          second rule).
          Then, it will check whether the <a>premises</a> of those rules hold, which may, in itself,
          require searching for rules with matching <a>conclusions</a>.
          Regarding general expressivity, these two reasoning modes can be considered equivalent.
          A detailed discussion of these two reasoning modes, their subtle differences and impacts on performance,
          is beyond the scope of this primer.
        </p>
      </section>
    </section>

    <section id='builtins' class='informative'>
      <h4>N3 Builtins</h4>
      <p>
        An <dfn data-lt="N3 builtin|builtin">N3 builtin</dfn> is used within an <a>N3 rule</a> to
        implement an arbitrary operation on an N3 <a>resource</a> or even an entire <a>N3 document</a>.
        Builtins include mathematic, string, time and cryptography operators,
        operations on collections and graphs, and logical operations in general.</p>

      <h5>Lists of built-ins</h5>
      <p>Built-ins are denoted by a controlled IRI defined in one of the core namespaces:</p>
      <ul>
        <li><a href="../ns/crypto.html">Crypto</a> â€“
          <a href="http://www.w3.org/2000/10/swap/crypto#">http://www.w3.org/2000/10/swap/crypto#</a>,
        </li>
        <li><a href="../ns/list.html">List</a> â€“
          <a href="http://www.w3.org/2000/10/swap/list#">http://www.w3.org/2000/10/swap/list#</a>,
        </li>
        <li><a href="../ns/log.html">Log</a> â€“
          <a href="http://www.w3.org/2000/10/swap/log#">http://www.w3.org/2000/10/swap/log#</a>,
        </li>
        <li><a href="../ns/math.html">Math</a> â€“
          <a href="http://www.w3.org/2000/10/swap/math#">http://www.w3.org/2000/10/swap/math#</a>,
        </li>
        <li><a href="../ns/string.html">String</a> â€“
          <a href="http://www.w3.org/2000/10/swap/string#">http://www.w3.org/2000/10/swap/string#</a>, and
        </li>
        <li><a href="../ns/time.html">Time</a> â€“
          <a href="http://www.w3.org/2000/10/swap/time#">http://www.w3.org/2000/10/swap/time#</a>.
        </li>
      </ul>

      <h5>Simple Builtins</h5>

      <p>
        <!-- An <a>N3 builtin</a> can be used within an <a>N3 rule</a> as part of an <a>N3 statement</a>. -->
        As a simple example, the rule below uses the `math:quotient` builtin to calculate a person's height in meters:
      </p>
      <pre id="builtin_age_example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix : <http://example.org/>.

:spiderman :heightInCm 180 .

{ ?person :heightInCm ?cm .
  ( ?cm 100 ) math:quotient ?m .
} => { ?person :heightInMeter ?m } . -->
</pre>
      <p>
        An <a>N3 builtin</a> is used as the <a>predicate</a> in an
        <dfn data-lt="N3 builtin statement|builtin statement">N3 builtin statement</dfn>,
        where the <a>subject</a> and <a>object</a> act as input or output arguments.
        In the example above, the second triple constitutes a <a>builtin statement</a>:
        the subject is the input, as `math:quotient` calculates the quotient of the subject <a>collection</a>
        elements (i.e., the person's height in cm and 100); the object constitutes the output,
        as the result is then bound to the object variable `?m`.
      </p>

      <h5>Builtins with Multiple Results</h5>

      <p><a>N3 builtins</a> can generate multiple results.
        Below, we use the `list:iterate` builtin to iterate over collection elements,
        and subsequently constructs a string for each element:</p>
      <pre id="iterate_example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix : <http://example.org/>.

:race :finalists ( :flash :superman :spiderman ) .
          
{ :race :finalists ?finalists .
  ?finalists list:iterate ( ?i ?finalist ) .
  ( ?i ". " ?finalist ) string:concatenation ?entry

} => { :race :entries ?entry } . -->
</pre>

      <p>
        The `list:iterate` builtin iterates over all elements in the subject collection (`?finalists`).
        For each element, it binds its index, and the element itself, to the variables in the object collection
        (`?i` and `?finalist`, respectively).
        Hence, the `list:iterate` builtin generates multiple sets of bindings for the `?i` and `?finalist`
        variables:<br />

        <code>( ?i = 1, ?finalist = :flash )</code><br />
        <code>( ?i = 2, ?finalist = :superman )</code><br />
        <code>( ?i = 3, ?finalist = :spiderman )</code><br />
        <br />

        For each set of bindings, the `string:concatenation` builtin concatenates the resources in the subject
        collection, and binds the result to the object variable (`?entry`).
        This will lead to the following object values:<br />
        "`1. :flash`" , "`2. :superman`" , and "`3. :spiderman`"
      </p>

      <p class="note">
        A <a>builtin statement</a> can be seen as a <a>triple pattern</a> that, for each builtin result,
        yields one or more "matching" triples depending on the builtin. For the example above:<br />
        <code>
            ( :flash :superman :spiderman ) list:iterate ( 1 :flash ) .<br />
            ( :flash :superman :spiderman ) list:iterate ( 2 :superman ) .<br />
            ( :flash :superman :spiderman ) list:iterate ( 3 :spiderman ) .<br />
          </code>
        <br />
        As with a <a data-cite="SPARQL11-QUERY#basicpatterns">SPARQL</a> query, for each "matching triple",
        a join is attempted with the remaining triples in the rule <a>premise</a>.
        Hence, for each matching triple, the `string:concatenation` <a>builtin statement</a> is evaluated.
        Finally, for each consistent set of variable bindings, the rule conclusion is instantiated and inferred.
      </p>

      <h5>Scoped Negation as Failure (SNAF)</h5>

      <p>
        <a>N3 builtins</a> can also operate on a local <a>graph term</a> or even an entire <a>N3 document</a>.
        The `log:collectAllIn`, `log:forAllIn`, and `log:notIncludes` builtins are logical operators that
        support a negation-as-failure scoped on the <a>builtin statement</a> object:
        the object can be a graph term or a <a>blank node</a>, in which case the current document is the scope.
        For instance, the rule below uses `log:collectAllIn` to collect all of spiderman's defeated villains
        found in the current document:
      <pre id="collectallin_example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix log: <http://www.w3.org/2000/10/swap/log#> . 
@prefix : <http://example.org/>.

:spiderman a :SuperHero .
:green-goblin :enemyOf :spiderman ; :defeated true .
:doctor-octopus :enemyOf :spiderman ; :defeated true .
:sandman :enemyOf :spiderman ; :defeated false .

{ 
  ?hero a :SuperHero .
  (?enemy
  {
    ?enemy :enemyOf ?hero ;
      :defeated true .
  }
  ?enemies) log:collectAllIn _:t .

} => { ?hero :defeatedEnemies ?enemies } . -->
</pre>

      The `log:collectAllIn` builtin accepts as subject a collection that includes:
      <ul>
        <li>a variable of which the values will be collected (`?enemy`),</li>
        <li>a <i>where</i> clause with triple patterns that constrain this variable, and</li>
        <li>a variable bound to the resulting collection of values (`?enemies`).</li>
      </ul>
      The <i>where</i> clause is evaluated on the given scope, in this case, the current <a>N3 document</a>;
      all potential results beyond this scope are considered false (SNAF).
      This leads to the following result:<br />
      &nbsp;&nbsp;&nbsp;&nbsp;<code>:spiderman :defeatedEnemies ( :green-goblin :doctor-octopus )</code><br />
      </p>
      <p>
        The example below uses `log:forAllIn` to determine whether a super-hero's identity is safe:
      <pre id="forallin_example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix log: <http://www.w3.org/2000/10/swap/log#> . 
@prefix : <http://example.org/> .

:spiderman a :SuperHero .
:mary-jane :knowsIdentityOf :spiderman ;
  :keepsSecrets true .
:aunt-may :knowsIdentityOf :spiderman ;
  :keepsSecrets true .

  { 
    ?hero a :SuperHero .
    ( { ?person :knowsIdentityOf ?hero } { ?person :keepsSecrets true } )               
      log:forAllIn _:t .

} => { ?hero :secretIdentitySafe true } . -->
</pre>
      The `log:forAllIn` builtin accepts as subject a collection with two clauses of a logical implication.
      If, for all cases where the first clause holds, the second clause holds as well,
      then the logical implication is true.
      In this example, the implication is true when, for each person who knows the identity of spiderman,
      this person can keep a secret.
      In this case the rule will fire, as both `mary-jane-watson` and `aunt-may` can keep secrets.
      </p>

      <p class="note">
        In the two examples above, the <a>blank node</a> object `_:t` indicates the current <a>N3 document</a>
        as scope. Alternatively, a <a>graph term</a> can be used as the scope as well.
        This is illustrated in the `log:notIncludes` example below.
      </p>

      <p>
        The `log:notIncludes` builtin checks whether the given scope <i>does not include</i> a given clause.
        The example below uses a <a>graph term</a> as scope, instead of the current <a>N3 document</a>,
        as was the case for the prior two examples.
        The rule finds any of spiderman's enemies who have not been defeated, at least,
        as reported by the Daily Bugle:
      <pre id="notincludes_example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix log: <http://www.w3.org/2000/10/swap/log#> . 
@prefix : <http://example.org/> .    

:spiderman :hasEnemy :green-goblin , :doctor-octopus, :sandman .
{
  :green-goblin :defeatedBy :spiderman .
  :doctor-octopus :defeatedBy :spiderman .

  } :reportedBy :daily_bugle .

{ 
  :spiderman :hasEnemy ?enemy .
  ?graph :reportedBy :daily_bugle .
  ?graph log:notIncludes { ?enemy :defeatedBy ?hero } .

} => { ?enemy a :Undefeated } . -->
</pre>
      <p>
        For each of spiderman's enemies (`?enemy`), the rule checks whether the <a>graph term</a> `?graph`,
        as reported by the `:daily_bugle`, does not include any statement where the enemy has been defeated.
        If so, we infer that this enemy is undefeated, in this case, `:sandman`.
      </p>

      <p class="note">
        The counterpart of `log:notIncludes` is `log:includes`, which checks whether the given object scope
        <i>includes</i> a given clause.
      </p>

      <h5>Access Online Knowledge</h5>
      <p>
        To dynamically retrieve online knowledge within an <a>N3 rule</a>,
        <code>log:semantics</code> and <code>log:conclusion</code> builtins allow pulling in, parsing, and reasoning
        over logical expressions from online sources.
      </p>
      <!-- <p>
        The example below uses `log:content` to retrieve an online HTML page,
        and subsequently extracts its title:
      <pre id="content_example" class="example nohighlight linkeditor" data-transform="updateExample"> -->
      <!--
            @prefix log: <http://www.w3.org/2000/10/swap/log#> . 
            @prefix string: <http://www.w3.org/2000/10/swap/string#> . 

            {
                <http://example.com> log:content ?content .
                ( ?content "<title>(.*?)</title>") string:scrape ?title .
            } => {
                <http://example.com> :title ?title . 
            } .
          -->
      <!-- </pre>
      </p> -->

      <p>
        In the rule below, the `log:semantics` builtin retrieves an online source and subsequently parses it a <a>graph
          term</a>:
      <pre id="semantics-example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix log: <http://www.w3.org/2000/10/swap/log#> . 
@prefix : <http://example.com> .

{ 	
  <https://raw.githubusercontent.com/w3c/N3/master/tests/N3Tests/people.n3> log:semantics ?g .
  ( ?person { ?person a :Person  } ?persons ) 
      log:collectAllIn ?g .
                 
} => { 
  <https://raw.githubusercontent.com/w3c/N3/master/tests/N3Tests/people.n3>
    :people ?persons
} . -->
</pre>
      Subsequently, `log:collectAllIn` is used to collect all persons found within the online source.
      </p>

      <p>
        The `log:conclusion` builtin allows generating the closure of a given <a>graph term</a>,
        i.e., extending the graph with all applicable rule inferences.
        This includes <a>graph terms</a> retrieved and parsed from online sources. For example:
      <pre id="concl-example" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix log: <http://www.w3.org/2000/10/swap/log#> . 
@prefix : <http://example.com/> .

{  <https://raw.githubusercontent.com/w3c/N3/master/tests/N3Tests/rules.n3> log:semantics ?g .
   ?g log:conclusion ?closure .
                
} => { 
   <https://raw.githubusercontent.com/w3c/N3/master/tests/N3Tests/rules.n3>
     :inferences ?closure
} . -->
</pre>
      Instead of simply printing the inferences, one could, e.g., use the `log:forAllIn` builtin to
      check whether all persons listed in the online source are indeed inferred to be animals as well.
      </p>
    </section>

    <section id='paths' class='informative'>
      <h4>Resource Paths</h4>
      <p>Similar to <a data-cite="SPARQL11-QUERY#propertypaths">SPARQL property paths</a>,
        N3 <dfn>resource paths</dfn> concisely express paths between resources,
        when intermediary resources on the path are not relevant.
        In practice, <a>resource paths</a> are most useful in <a href="#n3rules">N3 rules</a>.</p>

      <p>A <a>resource path</a> starts from a subject resource, followed by one or more predicates;
        each predicate is separated by a <dfn>directional indicator</dfn> to follow the predicate either forward (`!`)
        or in reverse (`^`).
        For example, the following example describes the city of Joe's mother's office's address:</p>

      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .

:joe!:hasMother!:hasOffice!:hasAddress :hasCity "Metropolis" . -->
</pre>

      <p>In this example, the intermediary resources &mdash; Joe's mother, her office, and its address &mdash;
        are not described or referenced further, so the more concise <a>resource path</a> syntax can be used.</p>

      <p>The expansion of this shorthand syntax uses blank nodes to express the path between the two resources.
        The example above is equivalent to the following (using blank node identifiers for clarity):</p>

      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .

:joe :hasMother _:m . 
_:m :hasOffice _:o . 
_:o :hasAddress _:a . 
_:a :hasCity "Metropolis" . -->
</pre>

      <p>In other words, each predicate in <a>resource path</a> is expanded into a statement,
        with as subject either the starting resource, or prior blank node object; and as object a newly minted blank
        node. </p>

      <p>Relations can also be followed in reverse using the reverse (`^`) indicator.
        The following example, starting from `joe`, follows the `hasMother` predicate to Joe's mother,
        and then follows the `hasMother` predicate in reverse (thus pointing to someone who has the same mother):</p>

      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .

:joe!:hasMother^:hasMother a :Person . -->
</pre>

      <p>This could equally well be represented by the more verbose:</p>

      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .

:joe :hasMother _:m.
_:d :hasMother _:m.
_:d a :Person. -->
</pre>

      <p class="note">In SPARQL, a property path is used in the
        <a data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</a> position to describe a string of relationships between
        a <a data-cite="RDF11-CONCEPTS#dfn-subject">subject</a> and an <a
          data-cite="RDF11-CONCEPTS#dfn-object">object</a> resource.
        In contrast, an N3 <a>resource path</a> is most often used in the <a
          data-cite="RDF11-CONCEPTS#dfn-subject">subject</a> or
        <a data-cite="RDF11-CONCEPTS#dfn-object">object</a> position.
        Using a <a>resource path</a> in the predicate position, although technically allowed, is often a mistake.
        For instance, the following N3 <a>resource path</a>: <br />
        &nbsp;&nbsp;&nbsp;&nbsp;`:joe :hasAddress!:hasCity "Metropolis" .`<br />
        Would lead to the following expansion:<br />
        &nbsp;&nbsp;&nbsp;&nbsp;`:joe _:bn_1 "Metropolis" .`<br />
        &nbsp;&nbsp;&nbsp;&nbsp;`:hasAddress :hasCity _:bn_1 .`<br />
        Which is likely not the intention of the author.
      </p>

    </section>
  </section>

  <section id='n3grammar'>
    <h2><abbr title="Extended Backusâ€“Naur Form">EBNF</abbr> Grammar</h2>
    <p>The <a data-cite="TURTLE#sec-grammar-grammar">Turtle grammar</a> was used as the starting point for the <dfn>N3
        grammar</dfn>, which was subsequently adapted and extended with N3 constructs.</p>
    <p>The N3 Working Group made the following decisions that modify the <a>N3 grammar</a> as originally presented in
      [[N3]]:
    <ul>
      <li>
        Dropping the <code>@keywords</code> declaration. It is complex and difficult to explain. Also, when using the
        declaration, <a>N3 documents</a> look wholly different from when it is not being used, since it allows
        <a>local
          names</a> in the default namespace to be listed without the "<code>:</code>" symbol.
      </li>
      <li>
        Supporting all verb and boolean keywords (<code>is .. of</code>, <code>has</code>, <code>a</code>,
        <code>true</code>, <code>false</code>) both with and without "<code>@</code>" prefix. Turtle supports the
        <code>a</code> keyword, i.e., without an "<code>@</code>", but requires the symbol for the
        <code>@prefix</code>
        and <code>@base</code> declarations. The <a data-cite="N3#grammar">original N3 grammar</a> required the
        "<code>@</code>" prefix for all verb and boolean keywords. Hence, this decision was made for compatibility
        with
        Turtle as well as to avoid an unintuitive grammar, i.e., where some keywords have the "<code>@</code>" prefix
        and some don't.
      </li>
      <li>
        Representing an inverted property using the <code>&lt;components-</code> symbol. The <a
          data-cite="N3#grammar">original N3 grammar</a> allowed the inverting of a property by using the
        <code>@is .. @of</code> construct. But, this construct can be unintuitive when property names are more
        verbosely
        specified (e.g., <code>:hasFather</code>), leading to statements such as
        <code>?x @is :hasFather @of ?y</code>.
        The <code>is .. of</code> construct is still supported, but the above statement can now be represented as
        follows: <code>?x &lt;- :hasFather ?y</code>.
      </li>
    </ul>
    <section id='whitespace'>
      <h3>Whitespace</h3>
      <p>White space (<a href="#grammar-production-WS">WS production</a>) is used to separate terminals. The amount
        and
        type of white space (e.g., newline (`%0A`) or space (`%20`)) is only significant within terminals.</p>
      <p>We note that the <a href="#grammar-production-IRIREF">IRIREF</a> production only allows IRI-encoded white
        spaces.</p>
    </section>
    <section id='comments'>
      <h3>Comments</h3>
      <p>Comments are indicated using a "<code>#</code>" symbol outside an N3 terminal (e.g., <a
          href="#grammar-production-IRIREF">IRIREF</a>, <a href="#grammar-production-STRING">STRING</a>) and will
        continue until the end of the line (indicated by <code>\r</code>, <code>\n</code> or <code>\f</code>) or end
        of file, if there is no end of line marker.</p>
      <p>All recognized comment terminals will be skipped by the grammar (i.e., a resulting parser will not call
        listener or visitor code when encountering a comment.)</p>
    </section>
    <section id='escseq'>
      <h3>Escape sequences</h3>
      <p>There are three forms of escapes used in <a>N3 documents</a>:</p>
      <ul>
        <li>
          Escape sequences in string literals. These are characters that are traditionally escaped in strings:
          <table>
            <thead>
              <tr>
                <th>Escape sequence</th>
                <th>Unicode code point</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>'\t'</td>
                <td>U+0009</td>
              </tr>
              <tr>
                <td>'\b'</td>
                <td>U+0008</td>
              </tr>
              <tr>
                <td>'\n'</td>
                <td>U+000A</td>
              </tr>
              <tr>
                <td>'\r'</td>
                <td>U+000D</td>
              </tr>
              <tr>
                <td>'\f'</td>
                <td>U+000C</td>
              </tr>
              <tr>
                <td>'\&quot;'</td>
                <td>U+0022</td>
              </tr>
              <tr>
                <td>'\''</td>
                <td>U+0027</td>
              </tr>
              <tr>
                <td>'\\'</td>
                <td>U+005C</td>
              </tr>
            </tbody>
          </table>
          (see the <a href="#grammar-production-ECHAR">ECHAR</a> production)
        </li>
        <li>
          Numeric escape sequences. These represent Unicode code points:
          <table>
            <thead>
              <tr>
                <th>Escape sequence</th>
                <th>Unicode code point</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>'\u' <a href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a> <a
                    href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a></td>
                <td>A Unicode character in the range U+0000 to U+FFFF inclusive
                  corresponding to the value encoded by the four hexadecimal digits interpreted from most significant
                  to
                  least significant digit.
                </td>
              </tr>
              <tr>
                <td>'\U' <a href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a> <a
                    href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a> <a
                    href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a> <a
                    href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a></td>
                <td>A Unicode character in the range U+0000 to U+10FFFF inclusive
                  corresponding to the value encoded by the eight hexadecimal digits interpreted from most significant
                  to least significant digit.
                </td>
              </tr>
            </tbody>
          </table>
          (see the <a href="#grammar-production-UCHAR">UCHAR</a> production)
        </li>
        <li>
          Escape sequences in <a>local names</a>. These escape the following reserved characters in the local name
          part
          of prefixed names: <code>_ ~ . - ! $ & \ ( ) * + , ; = / ? # @ %</code> (see the <a
            href="#grammar-production-PN_LOCAL_ESC">PN_LOCAL_ESC</a> production)
        </li>
      </ul>
    </section>
    <section id='irires'>
      <h3>IRI resolution</h3>
      <p> Relative IRIs are resolved with <a>base IRIs</a> using the algorithm in [[[RFC3986]]] [[RFC3986]]
        <a data-cite="RFC3986#section-5.2">Section 5.2 "Relative Resolution"</a>
        as supplemented by
        <a data-cite="RFC3987#section-6.5">Section 6.5</a>
        of [[[RFC3987]]] [[RFC3997]].
      </p>

      <p>The N3 <code>@base</code>
        or <code>BASE</code> directive can be used to
        define the <a>Base IRI</a>,
        per [[RFC3986]] <a data-cite="RFC3986#section-5.1.1">Section 5.1.1 "Base URI Embedded in Conent"</a>.
        Each `@base` or `BASE` directive sets a new In-Scope <a>Base IRI</a>,
        relative to the previous <a>base IRI</a>.</p>
    </section>
    <section id='pathres'>
      <h3>Resource path resolution</h3>
      <p><a>Resource paths</a> are resolved into zero or more N3 triples,
        and a single N3 triple element which is used as the
        <a href="#grammar-production-expression">expression</a> value
        of the <a>path</a>.
      </p>
      <p>This section describes two logically equivalent algorithms
        for transforming a <a>path</a> into a set of N3 triples,
        and providing a resource to use as the
        effective
        <a data-cite="RDF11-CONCEPTS#dfn-subject">subject</a>,
        <a data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</a>, or
        <a data-cite="RDF11-CONCEPTS#dfn-object">object</a>
        in place of the original <a>path</a> expression.
      </p>

      <section class="algorithm" id="pathres-reverse">
        <h4>Right to Left Algorithm</h4>
        <p>The first algorithm describes a means
          of processing a <a href="#grammar-production-path">path</a>
          starting from the right hand side of the <a>path</a>.
          This is essentially the algorithm described
          in the <a data-cite="N3#path">Team Submission</a>.
          This is useful for an implementation based
          processing an Abstract Syntax Tree generated
          by a parser, or where the entire path
          is treated as a token and language-specific
          tools are used to process it further.</p>

        <p>Processing is performed by
          recursively processing the <a>path</a> |p|,
          in reverse, from the
          last <a>directional indicator</a> (`!`) or (`^`).
          The result of resolving |p| into an
          <a href="#grammar-production-expression">expression</a>
          and set of emitted N3 triples
          MUST be equivalent to using the following algorithm:
        </p>

        <ol>
          <li>If |p| matches the
            <a href="#grammar-production-pathItem">pathItem</a> production,
            then |p| can be reduced no further, return |p|
            as the result.
          </li>
          <li>Otherwise, separate the |p| into two components
            <var>p<sub>n-1</sub></var> and <var>pred<sub>n</sub></var>
            on the last occurrence of the
            <a>directional indicator</a> <var>dir<sub>n</sub></var>.
          </li>
          <li>Create <var>obj<sub>n</sub></var>
            by invoking this algorithm recursively
            using <var>p<sub>n-1</sub></var> for |p|.</li>
          <li>Create a novel <a>blank node</a>
            <var>B<sub>n</sub></var>.
          </li>
          <li>If <var>dir<sub>n</sub></var> is "`!`",
            emit a new N3 triple
            (<var>obj<sub>n</sub></var>
            <var>pred<sub>n</sub></var>
            <var>B<sub>n</sub></var>).
          </li>
          <li>Otherwise, <var>dir<sub>n</sub></var> is "`^`",
            emit a new N3 triple
            (<var>B<sub>n</sub></var>
            <var>pred<sub>n</sub></var>
            <var>obj<sub>n</sub></var>).
          </li>
          <li>Return <var>B<sub>n</sub></var> as the result.</li>
        </ol>

        <aside class="example" title="Processing :john!:father right to left">
          <p>Starting with the <a>path</a> |p| set to `:john!:father`:</p>
          <ul>
            <li>Step 1 does not apply, as `:john!:father` is not a
              <a href="#grammar-production-pathItem">pathItem</a>.
            </li>
            <li>Step 2 separates `:john!:father` into
              <var>p<sub>n-1</sub></var> `:john`,
              <var>pred<sub>n</sub></var> `:father`, and
              <var>dir<sub>n</sub></var> "`!`".
            </li>
            <li>Step 3 sets <var>obj<sub>n</sub></var>
              by calling the algorithm
              recursively using |p| `:john`.
              <ul>
                <li>Step 1 returns `:john` as it matches a
                  <a href="#grammar-production-pathItem">pathItem</a>.
                </li>
                <li><var>obj<sub>n</sub></var> is `:john`.</li>
              </ul>
            </li>
            <li>Step 4 creates <var>B<sub>n</sub></var>.</li>
            <li>Step 5 matches because <var>dir<sub>n</sub></var> is "`!`".
              The triple (`:john` `:father` <var>B<sub>n</sub></var>) is emitted.</li>
            <li>Step 7 returns <var>B<sub>n</sub></var>.</li>
          </ul>
        </aside>

        <aside class="example" title="Processing :john^:father!:mother right to left">
          <p>Starting with the <a>path</a> |p| set to `john^:father!:mother`:</p>
          <ul>
            <li>Step 1 does not apply, as `john^:father!:mother` is not a
              <a href="#grammar-production-pathItem">pathItem</a>.
            </li>
            <li>Step 2 separates `:john^:father!:mother` into
              <var>p<sub>n-1</sub></var> `:john^:father`,
              <var>pred<sub>n</sub></var> `:mother`, and
              <var>dir<sub>n</sub></var> "`!`".
            </li>
            <li>Step 3 creates <var>B<sub>n</sub></var>.</li>
            <li>Step 4 sets <var>obj<sub>n</sub></var> by calling the algorithm
              recursively using |p| `:john^:father`.
              <ul>
                <li>Step 1 does not apply, as `:john^:father` is not a
                  <a href="#grammar-production-pathItem">pathItem</a>.
                </li>
                <li>Step 2 separates `:john^:father` into
                  <var>p<sub>n-2</sub></var> `:john`,
                  <var>pred<sub>n-1</sub></var> `:father`, and
                  <var>dir<sub>n-1</sub></var> "`^`".
                </li>
                <li>Step 3 creates <var>B<sub>n-1</sub></var>.</li>
                <li>Step 4 sets <var>obj<sub>n-1</sub></var>
                  by calling the algorithm
                  recursively using |p| `:john`.
                  <ul>
                    <li>Step 1 returns `:john` as it matches a
                      <a href="#grammar-production-pathItem">pathItem</a>.
                    </li>
                    <li><var>obj<sub>n-1</sub></var> is `:john`.</li>
                  </ul>
                </li>
                <li>Step 6 matches because |dir| is "`^`".
                  The triple (<var>B<sub>n-1</sub></var> `:father` `:john`) is emitted.</li>
                <li>Step 7 returns <var>B<sub>n-1</sub></var>.</li>
                <li><var>obj<sub>n</sub></var> is
                  <var>B<sub>n-1</sub></var>.
                </li>
              </ul>
            </li>
            <li>Step 5 matches because |dir| is "`!`".
              The triple
              (<var>B<sub>n-1</sub></var> `:mother` <var>B<sub>n</sub></var>)
              is emitted.</li>
            <li>Step 7 returns <var>B<sub>n</sub></var>.</li>
          </ul>
        </aside>
      </section>

      <section class="algorithm" id="pathres-forward">
        <h4>Left to Right Algorithm</h4>
        <p>The second algorithm describes a means
          of processing a <a href="#grammar-production-path">path</a>
          starting from the left hand side of a <a>path</a>.
          This is useful for an implementation based
          on the parser productions described in the grammar
          that create events in this order (i.e., event-based).</p>

        <p>Processing is performed by
          iteratively processing the <a>path</a> <var>p</var>,
          in the forward direction,
          from the first <a>directional indicator</a> (`!`) or (`^`).
          The result of resolving <var>p</var> into an
          <a href="#grammar-production-expression">expression</a>
          and set of emitted N3 triples
          MUST be equivalent to using the following algorithm:
        </p>

        <p>Initialize |n| to `0` and
          <var>B<sub>0</sub></var> to the first
          <a href="#grammar-production-pathItem">pathItem</a> in |p|.
          Repeat the following algorithm steps until return.
        </p>

        <p class="note"><var>B<sub>0</sub></var> starts
          as the first <a href="#grammar-production-pathItem">pathItem</a> in |p|,
          but is updated to
          a novel <a>blank node</a> on subsequent iterations.</p>

        <ol>
          <li>If |n| equals the number of <a>directional indicators</a> in |p|,
            return <var>B<sub>n</sub></var>.</li>
          <li>Increment |n|,
            set <var>B<sub>n</sub></var> to a novel <a>blank node</a>,
            set <var>dir<sub>n</sub></var> to the next (<var>n<sub>th</sub></var>)
            <a>directional indicator</a> <var>dir<sub>n</sub></var>
            (if any),
            set <var>pred<sub>n</sub></var> to the next
            <a href="#grammar-production-pathItem">pathItem</a>
            (if any).
          </li>
          <li>If <var>dir<sub>n</sub></var> is "`!`",
            emit a new N3 triple
            (<var>B<sub>n-1</sub></var> <var>pred<sub>n</sub></var> <var>B<sub>n</sub></var>).</li>
          <li>Otherwise, if <var>dir<sub>n</sub></var> is "`^`",
            emit a new N3 triple
            (<var>B<sub>n</sub></var> <var>pred<sub>n</sub></var> <var>B<sub>n-1</sub></var>).</li>
        </ol>

        <aside class="example" title="Processing :john!:father left to right">
          <p>Starting with the <a>path</a> |p| set to `:john!:father`;
            |n| is `0` and
            <var>B<sub>0</sub></var> is `:john`:
          </p>
          <ul>
            <li>Step 1 does not apply, as |n| is `0`.</li>
            <li>Step 2 increments |n| to `1`,
              sets <var>B<sub>1</sub></var> to a novel <a>blank node</a>,
              <var>dir<sub>1</sub></var> to "`!`", and
              <var>pred<sub>1</sub></var> to `:father`.
            </li>
            <li>Step 3 emits
              (`:john` `:father` <var>B<sub>1</sub></var>),
              as <var>dir<sub>1</sub></var> is "`!`"</li>
            <li>Looping back to step 1, |n| is `1`:
              <ul>
                <li>Step 1 returns <var>B<sub>1</sub></var>
                  as |n| is `1`, which is the number of
                  directional indicators in `:john!:father`.</li>
              </ul>
            </li>
          </ul>
        </aside>

        <aside class="example" title="Processing :john^:father!:mother left to right">
          <p>Starting with the <a>path</a> |p| set to
            `:john^:father!:mother`;
            |n| is `0` and
            <var>B<sub>0</sub></var> is `:john`:
          </p>
          <ul>
            <li>Step 1 does not apply,
              as |n| is `0`.</li>
            <li>Step 2 increments |n| to `1`,
              sets <var>B<sub>1</sub></var> to a novel <a>blank node</a>,
              <var>dir<sub>1</sub></var> to "`^`", and
              <var>pred<sub>1</sub></var> to `:father`.
            </li>
            <li>Step 4 emits
              (<var>B<sub>1</sub></var> `:father` `:john`),
              as <var>dir<sub>1</sub></var> is "`^`"</li>
            <li>Looping back to step 1, |n| is `1`:
              <ul>
                <li>Step 1 does not apply, as |n| is `1`.</li>
                <li>Step 2 increments |n| to `2`,
                  sets <var>B<sub>2</sub></var> to a novel <a>blank node</a>,
                  <var>dir<sub>2</sub></var> to "`!`", and
                  <var>pred<sub>2</sub></var> to `:mother`.
                </li>
                <li>Step 3 emits
                  (<var>B<sub>1</sub></var> `:mother` <var>B<sub>2</sub></var>),
                  as <var>dir<sub>2</sub></var> is "`!`"</li>
                <li>Looping back to step 1, |n| is `2`:
                  <ul>
                    <li>Step 1 returns <var>B<sub>2</sub></var>
                      as |n| is `2`, which is the number of
                      directional indicators in `:john^:father!:mother`.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </aside>
      </section>
    </section>
    <section id='grammar'>
      <h3>Grammar</h3>
      <div data-include="../grammar/n3.html"></div>
      <p>A textual version of this grammar may be found <a href="n3.ebnf">here</a>.</p>
    </section>
  </section>
  <section class=informative>
    <h2>Relationship to Other Languages</h2>
    <section id="rel-n3-turtle">
      <h3>Turtle</h3>
      <p>N3 is a superset of [[[turtle]]], meaning that all valid Turtle documents will be valid in N3 as well. The
        inverse is not true, i.e., a valid <a>N3 document</a> will not always be valid in Turtle.</p>
      <p>The current <a>N3 grammar</a> started from the <a data-cite="TURTLE#sec-grammar">Turtle grammar</a> which was
        adapted and extended to be in line with the <a data-cite="N3#grammar">original N3 grammar</a>. Hence, many of
        the grammar productions will be much more similar to the Turtle grammar than the initial N3 grammar.</p>
      <p>Important differences with Turtle are the following:</p>
      <ul>
        <li>Literals are allowed at any s/p/o position (i.e., subject, predicate or object) in a statement. See the <a
            href="#grammar-production-pathItem">pathItem</a> production, which is (eventually) referenced by the
          "subject", "predicate" and "object" productions.</li>
        <li>N3 includes <a>graph terms</a> (i.e., between "<code>{</code>" and "<code>}</code>"), which are allowed
          in any s/p/o position in a statement. See the <a href="#grammar-production-pathItem">pathItem</a>
          production.
        </li>
        <li>Quick-variables (e.g., "<code>?x</code>"), which are allowed in any s/p/o
          position in a statement. See the <a href="#grammar-production-pathItem">pathItem</a> production.
        </li>
        <li>A path syntax, comparable to (but not quite as extensive as) the <a
            data-cite="sparql11-query#propertypaths">SPARQL 1.1 Property Path</a> syntax. See the <a
            href="#grammar-production-path">path</a> production.</li>
        <li>The possibility to invert the predicate within a statement. See the <a
            href="#grammar-production-predicate">predicate</a> production.</li>
        <li>An additional set of keywords, including "<code>is .. of</code>", "<code>has</code>", "<code>=</code>",
          "<code>=></code>", "<code>&lt;=</code>", in addition to Turtle's "<code>a</code>" keyword (among others).
          All
          keywords can be optionally preceded by "<code>@</code>", for consistency with the "<code>@prefix</code>" and
          "<code>@base"</code> keywords.</li>
      </ul>
    </section>
    <section id="rel-n3-sparql">
      <h3>SPARQL</h3>
      <p>The <abbr title="SPARQL Protocol and RDF Query Language">SPARQL</abbr> 1.1 Query Language (SPARQL)
        [[SPARQL11-QUERY]] uses a Turtle-style [[turtle]] syntax for its <a
          data-cite="sparql11-query#rTriplesBlock">TriplesBlock production</a>. Differences between Turtle and SPARQL
        are elaborated in the <a data-cite="turtle#sec-diff-sparql">Turtle specification</a>.</p>
      <p>Below, we indicate some important differences between the <a
          data-cite="sparql11-query#rTriplesBlock">TriplesBlock production</a> and N3:</p>
      <ul>
        <li>
          Like N3, SPARQL permits literals as the subject of RDF triples, but, in contrast to N3, it does not allow
          literals as the predicate of RDF triples. Similarly,
          N3 allows for <a href="#bnodeprplist">blank node property lists</a> and <a>collections</a> in any position,
          whereas SPARQL only allows them in the subject or object position.
        </li>
        <li>
          Like N3, SPARQL permits variables in any part of the triple. But, in contrast to N3, SPARQL allows writing
          variables as both <code>?name</code> and <code>$name</code>, whereas N3 only allows <code>?name</code>.
        </li>
        <li>
          N3 allows <a href="#iris">prefix and base directives</a> anywhere outside of a triple. In SPARQL, they are
          only allowed in the <a data-cite="sparql11-query#rPrologue">Prologue</a> (i.e., at the start of the SPARQL
          query). However, in general, we also recommend listing prolog and base directives at the start of <a>N3
            documents</a>.
        </li>
        <li>
          In N3, most keywords (including <code>@prefix</code> and <code>@base</code> directives) are case sensitive,
          but most keywords in SPARQL are case-insensitive (aside from <code>a</code>). An exception in N3 are the
          <code>PREFIX</code> and <code>BASE</code> directives, which are derived from SPARQL and are case insensitive
          in N3 as well.
        </li>
        <li>
          The <a href="#paths">N3 path syntax</a> resembles the <a data-cite="sparql11-query#propertypaths">SPARQL 1.1
            Property Path</a> syntax, but there are important differences:
          <ul>
            <li>
              It is assumed that the <strong>path starts from a resource (<em>IR</em>) instead of a property
                (<em>IP</em>)</strong>. Hence, they are meant to be used in the subject and object positions, rather
              than the predicate position as is the case for SPARQL 1.1 property paths. This has important
              repercussions
              on how <a href="#pathres">paths are resolved</a>. Note that paths are unrelated to the inverted notation
              <code>^</code> for predicates (see the <a href="#grammar-production-predicate">predicate</a> production)
            </li>
            <li>
              Compared to SPARQL, N3 only supports the <em>SequencePath</em> and <em>InversePath</em> expressions, but
              with syntactic differences: the '<code>!</code>' symbol is used to separate path items, whereas the
              '<code>^</code>' symbol is used to indicate an inverse predicate.
            </li>
          </ul>
      </ul>
      <p>For more information, see the <a data-cite="sparql11-query#sparqlGrammar">SPARQL Grammar</a> section of
        [[[SPARQL11-QUERY]]].</p>
    </section>
    <section id="rel-n3-trig">
      <h3>TriG</h3>
      <p>[[[TRIG]]] is itself a superset of the Turtle syntax and includes a compact way to write RDF datasets, i.e.,
        sets of named graphs. In particular, TriG allows the specification of so-called graph statements, which are a
        pair of an <a>IRI</a> or blank node label and a group of triple statements surrounded by "<code>{</code>" and
        "<code>}</code>".</p>
      <p>For instance:</p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample">
  <!-- 
  # This document contains a default graph and two named graphs.
  @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
  @prefix dc: <http://purl.org/dc/terms/> .
  @prefix foaf: <http://xmlns.com/foaf/0.1/> .
  
  # default graph
  <http://example.org/bob> dc:publisher "Bob" .
  <http://example.org/alice> dc:publisher "Alice" .
  <http://example.org/bob>
  {
    _:a foaf:name "Bob" .
    _:a foaf:mbox <mailto:bob@oldcorp.example.org> .
    _:a foaf:knows _:b .
  }
  <http://example.org/alice>
  {
    _:b foaf:name "Alice" .
    _:b foaf:mbox <mailto:alice@work.example.org> .
  }
-->
</pre>
      <p>N3 is not directly compatible with TriG as it does not support this graph statement notation. Nevertheless,
        since N3 supports <a>graph terms</a> as part of regular <a>N3 statements</a>,
        authors can use the <a href="https://github.com/IDLabRese arch/N3NamedGraphSemantics">N3 Named Graphs
          extension</a>;
        this extension allows associating names or identifiers with <a>graph terms</a>.
        For instance:
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--

  @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
  @prefix dc: <http://purl.org/dc/terms/> .
  @prefix foaf: <http://xmlns.com/foaf/0.1/> .
  @prefix sem: <https://example.org/ns/semantics#> .
  
  # default graph
  <http://example.org/bob> dc:publisher "Bob" .
  <http://example.org/alice> dc:publisher "Alice" .
  <http://example.org/bob> sem:quotedGraph
    {
      _:a foaf:name "Bob" .
      _:a foaf:mbox <mailto:bob@oldcorp.example.org> .
      _:a foaf:knows _:b .
    } .
  <http://example.org/alice> sem:quotedGraph 
    {
      _:b foaf:name "Alice" .
      _:b foaf:mbox <mailto:alice@work.example.org> .
    } . -->
</pre>
      </p>
      <p>The <a href="https://github.com/IDLabResearch/N3NamedGraphSemantics">N3 Named Graphs extension</a>
        defines a set of <a>builtins</a> (used as predicates) to
        associate names or identifiers with <a>graph terms</a>, which then become "named graphs". Moreover, each
        predicate has a well-defined semantics on how the named graph should be interpreted: as <a>graph terms</a>
        (the default N3 interpretation), a partitioning of triples within a dataset context, sets of triples with
        their
        own isolated contexts, or specifying relations between local and online graphs.</p>
    </section>

    <!-- TODO -->
    <!-- <section>
      <h4>RDF-star</h4>
      <p>TODO</p>
    </section> -->

  </section>
  <section id='patterns' class=informative>
    <h3>Design Patterns</h3>
    <p>In this section, we present common patterns to solve often-occurring problems, for instance regarding data
      modeling, in N3.</p>
    <section id="naryrel">
      <h4>N-ary Relations</h4>
      <p>Until now, we only considered binary relations between entities and/or values. But, many types of relations
        are
        <em>ternary, quaternary, or, in general, n-ary in nature</em>, i.e., they have an arbitrary number of
        participants. Typical examples are purchase, employment, or membership relations.
      </p>
      <p>In other cases, we want to describe <em>properties of relations</em> &mdash; such as the provenance of a
        piece
        of information, or the probability of a diagnosis. But, in essence, this is the same problem as representing
        n-ary relations.</p>
      <p>There are several ways of representing n-ary relations in RDF &mdash; these are described in
        [[[swbp-n-aryRelations]]].</p>
      <p>Below, we illustrate options for representing n-ary relations in N3 in particular.</p>
      <section id="nary-binary-rel">
        <h4>Using sets of binary relations</h4>
        <p>In general, it is possible to convert any n-ary relation into an equivalent set of binary relations. This
          is
          a convenient solution, since we already know how to represent binary relations.</p>
        <p>First, we <em>create a resource</em> that represents the n-ary relation, and then <em>use a set of binary
            relations</em> to link each participant to this newly minted resource. Each binary relation is hereby
          given
          a meaningful name that <em>represents the role of the participant</em> in the n-ary relation.</p>
        <p>For instance, say we want to describe the <em>Purchase</em> relation between a buyer called "John", a
          purchased book called "Lenny the Lion", the amount paid for the book, and the seller:</p>
        <pre id="nary-book-relation" class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/> .

:Purchase_1 a :Purchase ;
  :hasBuyer :John ;
  :hasObject :Lenny_The_Lion ;
  :hasAmount 15 ;
  :hasSeller <http://books.example.com> . -->
</pre>
        <p class="note">Either you could mint a new <a>IRI</a> for representing the n-ary relation, or simply use a <a
            href="#bnodes">blank node</a>. In case other parties may want to refer to the n-ary relation from
          outside the N3 graph, one could choose to mint a new <a>IRI</a>.</p>
        <p>In other cases, things are more naturally described as <em>properties of relations</em>, rather than n-ary
          relations &mdash; for instance, the provenance of a piece of information, the trend of someone's body
          temperature and when the temperature was taken. Nevertheless, these can be represented in the same way as
          n-ary relation participants.</p>
        <p>We start from the same solution above, i.e., introducing a resource to represent the (in this case, binary)
          relation, and then linking the two participants to this resource. Subsequently, we use a set of binary
          relations to attach each descriptive property (e.g., diagnosis probability; temperature trend) to the
          relation
          resource.</p>
        <!-- <p>For instance, when describing a diagnosis (e.g., breast cancer) of someone (e.g., Christine), you may want to indicate the probability of the diagnosis, and the date at which the diagnosis was made:</p>
            <pre id="" class="example nohighlight linkeditor">
            @prefix ex: &lt;http://example.org/&gt; .
            @base &lt;http://example.org/&gt; .
            @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
            ex:Christine
              a       :Person ;
              :hasDiagnosis _:Diagnosis_Relation_1 .

            _:Diagnosis_Relation_1
              :diagnosisProbability :HIGH ;
              :diagnosisValue :Breast_Tumor_Christine ;
              :diagnosisDate ""
            </pre> -->
        <p>For instance, when describing someone's (e.g., Christine) current temperature, you may want to indicate the
          absolute value (e.g., 40 degrees), a description of that value (e.g., elevated), the trend compared to the
          prior value (e.g., rising), and the time the temperature was taken:</p>
        <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/> .

:Christine a :Person ;
  :hasTemperature _:to1 .

_:to1 :temperatureTrend :RISING ;
  :temperatureValue 40 ;
  :temperatureDescription :ELEVATED ;
   :temperatureTime "2020-07-12T09:01:33"^^xsd:dateTime . -->
</pre>
        <p>This is possible since we know that the relation resource (e.g., <code>_:to1</code>) represents the n-ary
          relation. Hence, any descriptive properties of the relation, in addition to participants in the relation,
          can
          simply be attached to the entity.</p>
        <p class="note">In this example, we made a statement with one of the participants (<code>:Christine</code>) as
          subject, and the relation resource (<code>_:to1</code>) as object. An alternative would have been to
          add
          <code>:Christine</code> as just another element of the n-ary relation, e.g., using a property
          <code>temperatureOf</code>. Our modeling choice here aimed to indicate that Christine is somehow the <a
            data-cite="swbp-n-aryRelations#useCase2">"owner" of the relationship</a>.
        </p>
        <!--
            (NOTE from a data modeling perspective, there would be a clear problem if the relation entity could have multiple "subjects" &mdash; e.g., in case it is being re-used to represent the same diagnosis for multiple patients. In that case, each of the patients'
            diagnosis probabilities would be linked to the same relation entity &mdash; and we lose the link that tells us which probability belongs to which patient. This can be seen as a kind of "fan trap".)
            -->
      </section>
      <section>
        <h4>Using collections</h4>
        <p>An alternative solution is to use a <a>collection</a> to keep all the participants of the n-ary relation.
          For instance:
        <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/> .

:avengers :members ( :iron_man :captain_america :spiderman ) . -->
</pre>
        A clear advantage of this approach is that it is easier and much less verbose to write down.
        However, the roles each participant play in the n-ary relation are no longer explicated.
        This is not a problem when the participants do not have different roles, as in the example above &mdash;
        they all play the same role of group member.
        </p>
      </section>
    </section>
    <section id="compoundliteral">
      <h4>Compound literal</h4>
      <p>This solution is inspired by a separate discussion within the RDF community on <em>Language Tagged
          Strings</em>.
        The essence of the discussion is to separate the string, as a simple data, from its various characterizations,
        such as reading direction and language.
        This design pattern uses the <code>rdf:CompoundLiteral</code> class together with the
        <code>rdf:language</code>, <code>rdf:direction</code>, and <code>rdf:value</code> properties
        to respectively describe literal values on the base direction, language, and string value of the subject.
        Please note that these various ways are still in flux,
        see the <a href="https://github.com/w3c/rdf-star-wg/blob/main/docs/text-direction.md">"text direction"</a>
        discussions in the RDF-star working group.
      </p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

<http://example.org/spiderman> foaf:name [
  rdf:value "Ø§Ù„Ø±Ø¬Ù„ Ø§Ù„Ø¹Ù†ÙƒØ¨ÙˆØª" ;
  rdf:language "ar-eg" ;
  rdf:direction "rtl"
] . -->
</pre>
    </section>
    <section id="reification">
      <h4>Graph Terms</h4>
      <p><a>Graph terms</a> allow attaching metadata to groups of triples,
        such as the provenance, context, version, opinion, probability, etc.
        See the example below:</p>
      <pre class="example nohighlight linkeditor" data-transform="updateExample"><!--
@prefix : <http://example.org/>  .

_:x :graph {
  <http://example.org/spiderman> <http://xmlns.com/foaf/0.1/name> "Peter Parker" .
} .
_:x :certainty 0.8 . -->
</pre>
      <p>Importantly, as discussed in the <a>graph terms</a> section,
        a graph term does not assert the contents of the RDF graph as being true.
        This allows expressing examples such as above,
        where the statement within the graph term should not be asserted.</p>
    </section>
  </section>
  <section id='semantics'>
    <h2>Semantics</h2>
    <p>The formal semantics of N3 is a work in progress.</p>
  </section>
  <section id='in-html' class="appendix informative">
    <h2>Embedding N3 in HTML documents</h2>
    <p>HTML [[HTML5]] <code>script</code> element can be used to embed data blocks in documents. N3 can be easily
      embedded in <code>script</code> with the <code>type</code> attribute set to <code>text/n3</code>.</p>
    <p>Such content may be escaped as indicated below:</p>
    <ul>
      <li><code>&amp;amp;</code>: &amp; (ampersand, U+0026)</li>
      <li><code>&amp;lt;</code>: &lt; (less-than sign, U+003C)</li>
      <li><code>&amp;gt;</code>: &gt; (greater-than sign, U+003E)</li>
      <li><code>&amp;quot;</code>: &quot; (quotation mark, U+0022)</li>
      <li><code>&amp;apos;</code>: &apos; (apostrophe, U+0027)</li>
    </ul>
    <pre class="example nohighlight" data-transform="updateExample">
      <!--
      <script type="text/n3">
        @prefix : &lt;http://example.org/&gt; .
        :green-goblin :enemyOf :spiderman .
      </script>
      -->
    </pre>
    <p>When embedded in XHTML N3 data blocks must be enclosed in CDATA sections. Those CDATA markers must be in Turtle
      comments. If the character sequence <code>]]&gt;</code> occurs in the document it must be escaped using strings
      escapes (<code>\u005d\u0054\u003e</code>). This will also make N3 safe in polyglot documents served as both
      <code>text/html</code> and <code>application/xhtml+xml</code>. Failing to use CDATA sections or escape
      <code>]]&gt;</code> may result in a non well-formed XML document.
    </p>

    <pre class="example nohighlight" data-transform="updateExample">
        <!--
        <script type="text/n3">
          # <![CDATA[
          @prefix : <http://example.org/> .
          :green-goblin :enemyOf :spiderman .
          # ]]>
        </script>
        -->
      </pre>
  </section>
  <section id='mime' class=appendix>
    <h2>Internet Media Type, File Extension and Macintosh File Type</h2>
    <p>This section has been submitted to the Internet Engineering Steering Group (IESG) for review, approval, and
      registration with IANA.</p>
    <dl>
      <dt>Contact:</dt>
      <dd>NAME</dd>
      <dt>Type name:</dt>
      <dd>text</dd>
      <dt>Subtype name:</dt>
      <dd>n3</dd>
      <dt>Optional parameters:</dt>
      <dd><code>charset</code> â€” this parameter is required when transferring non-ASCII data. If present, the value of
        <code>charset</code> is always <code>UTF-8</code>.
      </dd>
      <dt>Encoding considerations:</dt>
      <dd>The syntax of Notation3 is expressed over code points in Unicode [[UNICODE]]. The encoding is always UTF-8
        [[UTF-8]]. Unicode code points may also be expressed using an \uXXXX (U+0000 to U+FFFF) or \UXXXXXXXX syntax
        (for U+10000 onwards) where X is a hexadecimal digit [0-9A-Fa-f]</dd>
      <dt>Security considerations:</dt>
      <dd>Notation3 is a general-purpose assertion language; applications may evaluate given data to infer more
        assertions or to dereference <a>IRIs</a>, invoking the security considerations of the scheme for that
        <a>IRI</a>. Note in particular, the privacy issues in [[RFC3023]] section 10 for HTTP <a>IRIs</a>. Data
        obtained
        from an inaccurate or malicious data source may lead to inaccurate or misleading conclusions, as well as the
        dereferencing of unintended <a>IRIs</a>. Care must be taken to align the trust in consulted resources with the
        sensitivity of the intended use of the data; inferences of potential medical treatments would likely require
        different trust than inferences for trip planning. Notation3 is used to express arbitrary application data;
        security considerations will vary by domain of use. Security tools and protocols applicable to text (e.g. PGP
        encryption, MD5 sum validation, password-protected compression) may also be used on Notation3 documents.
        Security/privacy protocols must be imposed which reflect the sensitivity of the embedded information.
        Notation3
        can express data which is presented to the user, for example, RDF Schema labels. Application rendering strings
        retrieved from untrusted Notation3 documents must ensure that malignant strings may not be used to mislead the
        reader. The security considerations in the media type registration for XML ([[RFC3023]] section 10) provide
        additional guidance around the expression of arbitrary data and markup. Notation3 uses <a>IRIs</a> as term
        identifiers. Applications interpreting data expressed in Notation3 should address the security issues of
        Internationalized Resource Identifiers (<a>IRIs</a>) [[RFC3987]] Section 8, as well as Uniform Resource
        Identifier (URI): Generic Syntax [[RFC3986]] Section 7. Multiple <a>IRIs</a> may have the same appearance.
        Characters in different scripts may look similar (a Cyrillic "Ð¾" may appear similar to a Latin "o"). A
        character
        followed by combining characters may have the same visual representation as another character (LATIN SMALL
        LETTER E followed by COMBINING ACUTE ACCENT has the same visual representation as LATIN SMALL LETTER E WITH
        ACUTE). Any person or application that is writing or interpreting data in Notation3 must take care to use the
        <a>IRI</a> that matches the intended semantics, and avoid <a>IRIs</a> that make look similar. Further
        information about matching of similar characters can be found in Unicode Security Considerations
        [[UNICODE-SECURITY]] and Internationalized Resource Identifiers (<a>IRIs</a>) [[RFC3987]] Section 8.
      </dd>
      <dt>Interoperability considerations:</dt>
      <dd>Not Applicable</dd>
      <dt>Published specification:</dt>
      <dd>This specification.</dd>
      <dt>Applications which use this media type:</dt>
      <dd>Any programming environment that requires the exchange of directed graphs. Implementations of Notation3 have
        been created for JavaScript, Python, Java, and Prolog. It may be used by some web services and clients
        consuming
        their data.</dd>
      <dt>Additional information:</dt>
      <dt>Magic number(s):</dt>
      <dd>Notation3 documents may have the strings 'prefix' or 'base' (case independent) near the beginning of the
        document.</dd>
      <dt>File extension(s):</dt>
      <dd>.n3</dd>
      <dt>Macintosh file type code(s):</dt>
      <dd>TEXT</dd>
      <dt>Person &amp; email address to contact for further information:</dt>
      <dd>NAME &lt;EMAIL&gt;</dd>
      <dt>Intended usage:</dt>
      <dd>Common</dd>
      <dt>Restrictions on usage:</dt>
      <dd>None</dd>
      <dt>Author(s):</dt>
      <dd>DÃ¶rthe Arndt, William Van Woensel, Dominik Tomaszuk</dd>
      <dt>Change controller:</dt>
      <dd>W3C</dd>
    </dl>
  </section>
  <section id="changes-since-team-submission" class="appendix informative">
    <h2>Changes since the Team Submission</h2>
    <p>The following is a summary of changes made since the
      original Team Submission [[N3]]:</p>
    <ul>
      <li>Removed support for `@keywords` customizations.</li>
      <li>Removed `@a`, `@in`, and `@of` in favor of `a`, `in`, and `of`.</li>
      <li>Added `&lt;-` to represent an inverted property as a synonym of `is` <a
          href="#grammar-production-expression">expression</a> `of`.
      <li>Removed `@true` and `@false` in favor of `true` and `false`.</li>
      <li>Removed `@has`.</li>
      <li>Removed support for explicit <strong>N3 quantifiers</strong>
        (`@forSome` and `@forAll`).</li>
      <li>Removed whitespace from the
        <a href="#grammar-production-IRIREF">IRIREF</a> grammar terminal
        to be consistent with Turtle.
      </li>
    </ul>
    <p class="ednote">There are more accumulated changes to account for, to be sure.</p>
  </section>
  <section id='aknowledgements' class="appendix informative">
    <h2>Acknowledgements</h2>
    <p>The editors acknowledge valuable contributions from...</p>
  </section>
</body>

</html>