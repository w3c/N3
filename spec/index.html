<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset='utf-8'>
  <title>Notation3</title>
  <!-- <script async class='remove' src='respec-w3c.js'></script> -->
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
  <script class='remove'>
    var respecConfig = {
      specStatus: "CG-DRAFT",
      editors: [ // here edit the editors
        {
          name: "Dörthe Arndt",
          company: "TU Dresden",
          companyURL: "https://tu-dresden.de",
          mailto: "doerthe.arndt@tu-dresden.de"
        },
        {
          name: "William Van Woensel",
          company: "Dalhousie University",
          companyURL: "https://www.dal.ca/",
          mailto: "william.van.woensel@dal.ca"
        },
        {
          name: "Dominik Tomaszuk",
          company: "University of Bialystok",
          companyURL: "https://uwb.edu.pl",
          mailto: "d.tomaszuk@uwb.edu.pl"
        },
        {
          name: "Gregg Kellogg",
          mailto: "gregg@greggkellogg.net"
        }
      ],
      github: {
        repoURL: "https://github.com/w3c/N3",
        branch: "master"
      },
      shortName: "N3",
      group: "cg/n3-dev",
      wgPublicList: "public-n3-dev",
      edDraftURI: "https://w3c.github.io/N3/spec/",
      testSuiteURI: "https://w3c.github.io/N3/tests/",
      localBiblio: {
        "LNG-TAG": {
          title: "Language Subtag Registry",
          href: "http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry",
          publisher: "IANA"
        }
      }
    };
  </script>
  <style>
    table,
    th,
    td {
      border: 1px solid black;
      border-collapse: collapse;
      padding: 5px;
    }

    table.grammar,
    table.grammar th,
    table.grammar td {
      border: none;
      padding: 2px;
      vertical-align: top;
    }

    table.grammar td:nth-child(2) {
      text-align: right;
    }

    table.ex,
    .ex th,
    .ex td {
      border: none;
      padding: 0;
    }

    .ex th {
      text-align: center;
    }
  </style>
  <script>
    function _esc(s) {
      return s.replace(/&/g, '&amp;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/</g, '&lt;');
    }

    function unComment(doc, content) {
      // perform transformations to make it render and prettier
      return content
        .replace(/<!--/, '')
          .replace(/--> /, '')
            .replace(/< !\s*-\s*-/g, '<!--')
            .replace(/-\s*- >/g, '-->')
            .replace(/-\s*-\s*&gt;/g, '--&gt;');
    }

    function updateExample(doc, content) {
      // perform transformations to make it render and prettier
      return _esc(unComment(doc, content));
    }
  </script>
</head>

<body>
  <section id='abstract'>
    <p>
      This document defines Notation 3 (also known as <abbr title="Notation3">N3</abbr>), an assertion and logic
      language which is a superset of <abbr title="Resource Description Framework">RDF</abbr>.
    </p>
  </section>
  <section id='sotd'>
    <p>
      This is very early draft of the Notation3 specification.
    </p>
  </section>
  <!--
      How to edit this HTML?
      https://dev.w3.org/2008/video/mediaann/ReSpec.js/documentation.html
      https://github.com/w3c/respec
      -->
  <section id='introduction'>
    <h2>Introduction</h2>
    <p>The Semantic Web represents a vision of online and interconnected knowledge.
      The core building block is a logical formalism called the Resource Description Framework (RDF)
      ([[[RDF11-PRIMER]]]).
      RDF includes logical conjunctions of statements, each describing properties of resources, the properties of the
      objects of those properties, and so on; ultimately, leading to a Knowledge Graph.
      It builds on the fundamental identification mechanism of the Web, i.e., the Uniform Resource Identifier (URI),
      also known as International Resource Identifier (<abbr title="International Resource Identifier">IRI</abbr>), as a
      means to identify any RDF resource, ranging from abstract concepts (the book "Moby Dick") to physical (a paper
      copy of the book "Moby Dick") to electronic objects (an e-book copy of "Moby Dick").
      People have used RDF to build vast quantities of online, connected Knowledge Graphs. The Semantic Web has set the
      stage for decision making within an open environment of interconnected knowledge graphs, as opposed to a closed
      system of locally trusted facts.</p>
    <p>Notation3 Logic, or N3 for short, aims to implement such decision-making abilities in an open web environment
      &mdash; by (a) extending the representational abilities of RDF and (b) allowing access to and reasoning over
      online information.
      N3 attempts to walk the line between, on the one hand, ease-of-use by authors and simplicity of reasoning for
      developers; and, on the other hand, extended utility and practicality for building real-world applications.</p>
    <p>The main characteristics of N3 are as follows:</p>
    <ul>
      <li>
        <strong>N3 is a superset of RDF and <abbr title="Terse RDF Triple Language">Turtle</abbr>.</strong>
        Any valid [[[Turtle]]] graph will be valid in N3 as well, meaning that all of Turtle's syntactic sugar is
        available in N3 &mdash; including <a href="#polists">predicate and object lists</a> and unlabeled blank nodes.
        Moreover, <strong><a>collections</a> are first-class citizens</strong> in N3, with an associated set of
        <a>built-ins</a> for accessing and manipulating them.
      </li>
      <li>
        <strong>N3 adds logical implications and universal variables.</strong>
        Logical implications with variables allow making expressive If-Then style inferences via modus ponens (where
        implementations may apply either backward- or forward-chaining).
        Rule variables may be quantified either universally or existentially.
      </li>
      <li>
        <strong>N3 supports quoting and describing graphs of statements.</strong>
        A <a>quoted graph</a> includes a conjunction of quoted statements. It allows expressing where particular
        statements came from, at what time they were stated and by whom (i.e., provenance), and any other description in
        general.
      </li>
      <li>
        <strong>N3 includes <a>built-ins</a> for accessing online knowledge.</strong>
        To dynamically retrieve online knowledge for decision making, the <code>log:content</code>,
        <code>log:semantics</code>, and <code>log:conclusion</code> builtins allow pulling in, parsing, and reasoning
        over logical expressions from online or local sources.
      </li>
      <li>
        <strong>N3 supports a scoped version of negation-as-failure.</strong>
        It can be useful to check whether a <em>specific online source or local graph</em>, at a given point in time,
        does or does not support a set of facts.
        This is referred to as <em>scoped negation as failure,</em> and is supported by N3's
        <code>log:notIncludes</code> <a>built-in</a>.
      </li>
    </ul>
    <!-- <p class="ednote">Should we highlight <code>log:semantics</code> and <code>log:conclusion</code> that much? They are still causing lots of discussion.
        Maybe we could highlight other useful built-ins instead? Of course, then we would need other constructs for snaf</p> -->
  </section>
  <section id="conformance">
  </section>

  <section id='language' class=informative>
    <h2>Language</h2>
    <p>The aim of this section is to provide an informal overview of the N3 language and its different features. Where
      possible, this section is based on the [[[Turtle]]] specification. More formal definitions will follow in the
      subsequent sections.
    </p>
    <section id='n3doc'>
      <h3>N3 document</h3>
      <p>An <dfn>N3 document</dfn> represents an <a>N3 graph</a> in a compact textual form. An <dfn>N3 graph</dfn>
        is a series of <dfn data-lt="statement|triple">N3 statements</dfn>. These are written as <a>triples</a>
        consisting of a
        <a data-cite="RDF11-CONCEPTS#dfn-subject">subject</a>,
        <a data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</a>, and
        <a data-cite="RDF11-CONCEPTS#dfn-object">object</a>.
        In its simplest form, a triple expresses a relation between <a href="#iris">IRIs</a>, <a
          href="#literals">literals</a> or <a href="#bnodes">blank nodes</a>. N3 also allows more advanced elements and
        statements &mdash;
        <a>quoted graphs</a> for quoting sets of statements,
        <a href="#logimpl">logical implications</a> for rule-based reasoning, quantified variables, builtin statements,
        and so on.
        We introduce these types of elements and statements below.
      </p>
      <p>Comments are indicated using a separate '#' and continue until the end of the line.
      </p>
    </section>
    <section id='simpletriples'>
      <h4>Simple triples</h4>
      <p>The simplest <a>N3 statement</a> or <a>triple</a> is a sequence of
        <a data-cite="RDF11-CONCEPTS#dfn-subject">subject</a>,
        <a data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</a>, and
        <a data-cite="RDF11-CONCEPTS#dfn-object">object</a>,
        separated by whitespace and terminated by '`.`' after each <a>triple</a>.
      <p>In the example below, three <a>N3 triples</a> highlight the enmity between Spiderman and the Green Goblin and
        lists their human-readable names:</p>
      <!--
          NOTE: there is a data-include attribute
          (https://github.com/w3c/respec/wiki/ReSpec-Editor's-Guide#inclusions--transformations)
          that allows you to directly include a data file here
          -->
      <pre class="example nohighlight" id="basic-triples-example" data-transform="updateExample">
          <!--
          <http://example.org/#spiderman> <http://example.org/#enemyOf> <http://example.org/#green-goblin> .
          <http://example.org/#spiderman> <http://xmlns.com/foaf/0.1/name> "Spiderman" .
          <http://example.org/#green-goblin> <http://xmlns.com/foaf/0.1/name> "Green Goblin" .
            -->
        </pre>

      For now, we will asssume that a resource is represented either by an <a>IRI</a> or a <a
        href="#literals">literal</a>.
      In general, one uses an <a>IRI</a> to identify an identifiable entity such as a person, place, or thing &mdash;
      a literal is used for a textual or numerical (i.e., datatype) value, such as name, date, height, and so on.</p>

      <p class="note">There is no inherent order for N3 or RDF triples. The same is true for the relational database
        model, i.e., relational tuples or rows do not have an inherent order. Hence, it is a mistake to associate
        meaning with the order of statements in an N3 document (e.g., assuming that a first listed telephone for
        Spiderman is their landline, and the second one their mobile number).</p>
      <!-- <p class="note">Examples will often be written using newlines and tab spaces for readability. However, generally, only the subjects, predicates and objects need to be separated with a whitespace.</p> -->
      <!-- <pre class="example nohighlight">&lt;http://example.org/#dt&gt; &lt;http://xmlns.com/foaf/0.1/name&gt; &quot;Dominik Tomaszuk&quot; .</pre> -->
    </section>
    <section id='polists'>
      <h4>Predicate and object lists</h4>
      <p>As shown in the above example, the same subject (here, Spiderman) will often be described by several <a>N3
          statements</a>.
        To make these <a>N3 statements</a> less cumbersome to write, one can put a semicolon ("<code>;</code>") at the
        end of an <a>N3 statement</a> to describe the same subject in the subsequent statement:</p>
      <pre class="example nohighlight" id="predicate-lists-example" data-transform="updateExample">
          <!--
          <http://example.org/#spiderman>
              <http://example.org/#enemyOf> <http://example.org/#green-goblin> ;
              <http://xmlns.com/foaf/0.1/name> "Spiderman" .
          -->
        </pre>
      <!-- <pre class="example nohighlight">&lt;http://example.org/#dt&gt; &lt;http://xmlns.com/foaf/0.1/firstName&gt; &quot;Dominik&quot; ;
          &lt;http://xmlns.com/foaf/0.1/lastName&gt; &quot;Tomaszuk&quot; .</pre> -->
      <p>Similarly, a predicate (e.g., name) can often list multiple objects for the same subject (e.g., Spiderman).
        This can be written by listing the object values separated by a '<code>,</code>':</p>
      <pre class="example nohighlight" id="object-lists-example" data-transform="updateExample">
          <!--
          <http://example.org/#spiderman>
              <http://xmlns.com/foaf/0.1/name> "Spiderman", "Peter Parker" .
          -->
        </pre>
      <!-- <pre class="example nohighlight">&lt;http://example.org/#dt&gt; &lt;http://xmlns.com/foaf/0.1/nick&gt; &quot;Domel&quot;, &quot;Misiek&quot;@pl .</pre> -->
    </section>
    <section id='iris'>
      <h3>IRIs</h3>
      <p>An IRI is used to represent an identifiable entity &mdash; such as a person, place, or thing. 
        Until now, we have been writing absolute <dfn data-lt="absolute iri|iri">IRIs</dfn> [[RFC3987]] (e.g.,
        <code>http://example.org/#Spiderman</code>), which include both the namespace (e.g.,
        <code>http://example.org/#</code>) and the local name (e.g., <code>Spiderman</code>).
      </p>

      <p>It is often much easier to write an IRI as a <dfn>prefixed name</dfn> &mdash; e.g., <code>ex:Spiderman</code>,
        which includes a <dfn>prefix label</dfn> (e.g., <code>ex</code>) as a shorthand for the namespace,
        and the <dfn>local name</dfn> (e.g., <code>Spiderman</code>), separated by a colon ("<code>:</code>").
        The `@prefix` directives associate the <a>prefix label</a>
        with a <dfn>namespace IRI</dfn>. A prefixed name is turned into an absolute <a>IRI</a>
        by concatenating the <a>namespace IRI</a> with the <a>local name</a>.
        The following example is equivalent to the <a href="#basic-triples-example">original example</a>:</p>
      <pre class="example nohighlight" id="prefixed-names-example" data-transform="updateExample">
          <!--
          @prefix ex: <http://www.example.org/#> .
          @prefix foaf: <http://xmlns.com/foaf/0.1/> .

          ex:spiderman ex:enemyOf ex:green-goblin ;
            foaf:name "Spiderman" .
          ex:green-goblin foaf:name "Green Goblin" .
          -->
        </pre>

        <p class="note">N3 also supports
          case-insensitive `PREFIX` and `BASE` directives, as does Turtle,
          to align the syntax with SPARQL (see <a href="#grammar">grammar</a>). 
          These do not have a trailing '.'.
        </p>

      <p>To further simplify prefixed names, one can leave the <a>prefix label</a> empty (e.g., for an often-used
        namespace):</p>
      <pre class="example nohighlight" id="empty-prefix-example" data-transform="updateExample">
          <!--
          @prefix : <http://www.example.org/#> .

          :spiderman :enemyOf :green-goblin .
          -->
        </pre>

      <p>One can also write <dfn data-lt="relative iri">relative IRI references</dfn>, e.g., <code>&lt;#Spiderman&gt;</code>.
        A relative IRI reference is <a data-cite="RFC3987#section-6.5">resolved</a>, i.e., turned into an <a>absolute IRI</a>, by concatenating the base IRI with the <a>local name</a> (e.g., <code>Spiderman</code>).
        A <dfn>base IRI</dfn> is defined using the `@base` directive.
        For instance, the following is equivalent to the <a href="#empty-prefix-example">prior example</a>:
      </p>
      <pre class="example nohighlight" id="relative-iri-example" data-transform="updateExample">
          <!--
          @base <http://www.example.org/#> .

          <#spiderman> <#enemyOf> <#green-goblin> .
          -->
        </pre>
      <p>Specifics of <a>relative IRI reference</a>
        <a data-cite="RFC3986#section-5.2">resolution</a> are described in
        <a href="#irires" class="sectionRef"></a>.
      </p>

      <p class="note">We recommend listing `@prefix` / `PREFIX` and `@base` / `BASE` declarations
        at the top of an <a>N3 document</a>.
        This is not mandatory, however,
        and they can technically be put anywhere before
        the <a>prefixed name</a> or <a>relative IRI</a>
        that relies on the declaration.
        Subsequent `@prefix` / `PREFIX` directives may "re-map"
        the same <a>prefix label</a> to another <a>namespace IRI</a>.</p>

      <div class="note">
        <p>Prefixed names are a superset of <a href="https://www.w3.org/2001/tag/doc/qnameids.html">XML QNames</a>.
          They differ in that the local name may include:</p>

        <ul>
          <li>leading digits, e.g. `leg:3032571` or `isbn13:9780136019701`</li>
          <li>non leading colons, e.g. `og:video:height`</li>
          <li>reserved character escape sequences, e.g. `wgs:lat\-long`</li>
        </ul>
      </div>

      <!-- <pre class="example nohighlight">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
          @prefix : &lt;http://example.org/#&gt;

          &lt;http://example.org/#doerthe&gt; foaf:knows &lt;http://example.org/#dominik&gt; .
          :doerthe foaf:knows :dominik .</pre> -->

        <section id='iriprplist'>
          <h4>IRI property lists</h4>
          <p>
            In many cases, an <a>IRI</a> occurs only once as an object, and is then further described as a subject in other statements
            (e.g., see a <a href="#prefixed-names-example">prior example</a>). 
            The <a href="#iri-prp-list-unfolded">example below</a> illustrates how this may result in difficult-to-read code:
            to find descriptions of <a>IRI</a> objects such as `tobey-maguire` or `willem-dafoe`, one must scan the full <a>N3 graph</a>,
            as they are only described near the end.</p>

          <p>Using the IRI property list syntax, descriptions of these object <a>IRIs</a> can be directly "embedded" within the object position:</p>
  
          <table class="ex">
            <tr>
              <th>Using basic statements:</th>
              <th>Using IRI property lists:</th>
            </tr>
            <tr>
              <td>
                <pre class="example no-highlight" id="iri-prp-list-unfolded" data-transform="updateExample">
                  <!--
                  @prefix : <http://example.org/#> .
                  @prefix foaf: <http://xmlns.com/foaf/0.1/> .
    
                  :spiderman 
                    :enemyOf :green-goblin ;
                    :portrayedBy :tobey-maguire .
    
                  :green-goblin 
                    :portrayedBy :willem-dafoe .

                  :tobey-maguire a :Actor .
                  :willem-dafoe a :Actor .
                  -->
                </pre>
              </td>
              <td>
                <pre class="example no-highlight" id="iri-prp-list" data-transform="updateExample">
                  <!--
                  @prefix : <http://example.org/#> .
                  @prefix foaf: <http://xmlns.com/foaf/0.1/> .
    
                  :spiderman 
                    :enemyOf 
                      [ id :green-goblin 
                        :portrayedBy [ id :willem-dafoe
                          a :Actor 
                        ]
                    ] ;
                    :portrayedBy [ id :tobey-maguire
                      a :Actor
                    ] .
                  -->
                </pre>
              </td>
            </tr>
          </table>
  
          <p>IRI property lists build on the <a href="#polists">predicate object list</a> syntax to group statements about <a>IRIs</a>.
          One can use <a href="#object-lists-example">objects lists</a> in this syntax as well.
          </p>

          <p class="note">See also the <a href="#bnodeprplist">blank node property list</a> syntax.</p>
          <p class="note">See <a data-cite="JSON-LD11#embedding">embedding</a> in [[JSON-LD11]] for a discussion of a similar feature in
            another format.</p>

        </section>

    </section>
    
    <section id='literals'>
      <h3>Literals</h3>
      <p>Literals are used to represent a textual or numerical (i.e., datatype) value, such as name,
        date, height, and so on. Numbers (integers, decimals, and doubles) are simply represented using their
        numerical value, and booleans are represented using <code>true</code> or <code>false</code>:</p>
      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix : <http://example.org/elements> .
          @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

          <http://en.wikipedia.org/wiki/Helium>
            :atomicNumber 2 ;               # xsd:integer
            :atomicMass 4.002602 ;          # xsd:decimal
            :specificGravity 1.663E-4 ;     # xsd:double
            :isNobleGas true ;              # xsd:boolean
            rdfs:label "Helium" .           # xsd:string
          -->
        </pre>
      <p>For details on numerical syntaxes (e.g., decimals, doubles), we refer to the <a
          data-cite="TURTLE#abbrev">RDF 1.1: Turtle (Section 2.5.2)</a> specification.</p>
      <p>Other literals, such as strings, but also dates, binary, octal or hex code, XML or JSON code, or other types of numbers (e.g., shorts), need to be written as <b>string literals</b>. If the literal is not a string, its particular datatype must be indicated using the <code>^^</code> symbol and the corresponding <dfn data-cite="XMLSCHEMA11-2#built-in-datatypes">datatype IRI</dfn>. For instance:</p>

      <pre class="example nohighlight" data-transform="updateExample">
      <!--
      @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
      @prefix : <http://example.org/#> .

      :spiderman
          :birthDate "2001-08-10"^^xsd:date .
      -->
    </pre>

    The literal's <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> will include the characters between
    the delimiter quotes (e.g., <code>2001-08-10</code>).

      <p>The language of the string literal can be indicated using the <code>@</code> symbol and the corresponding
        language tag (as defined in [[BCP47]] &mdash; find the registry in [[LNG-TAG]]). For instance:</p>
      <pre class="example nohighlight" data-transform="updateExample">
      <!--
      @prefix foaf: <http://xmlns.com/foaf/0.1/> .
      @prefix : <http://example.org/#> .

      :spiderman foaf:name "Spiderman"@en ,
          "Hombre Araña"@es , "Homme Araignée"@fr .
      -->
    </pre>
      <p>The reading direction can be described together with the language [[BCP47]], using the <code>i18n</code>
        namespace:</p>
      <pre class="example nohighlight" data-transform="updateExample">
      <!--
      @prefix i18n: <https://www.w3.org/ns/i18n#> .
      @prefix foaf: <http://xmlns.com/foaf/0.1/> .
      @prefix : <http://example.org/#> .

      :spiderman foaf:name "الرجل العنكبوت"^^i18n:ar-eg_rtl .
      -->
    </pre>

      <p class="note">If no <a>datatype IRI</a> or language tag is given, the datatype <code>xsd:string</code> will be
        assumed. In case a language tag is given, the datatype <code>rdf:langString</code> will be assumed. Note that it
        is not possible to specify both a <a>datatype IRI</a> and a language tag.</p>

      <p class="note">Integers, decimals, doubles, and booleans may also be written as string literals with the
        appropriate <a>datatype IRI</a> (e.g., `"8"^^xsd:int` or "true"^^xsd:boolean).
      </p>

      <p class="note">There are also <a href="#compoundliteral">other mechanisms</a> for describing the language tag and
        base direction of RDF literals.</p>

      <p>In case the the string literal itself contains the string delimiter (e.g., double quotes), or includes newlines, other string delimiters can be used, i.e., single quotes or compound delimiters <code>"""</code> or <code>'''</code>.
        Alternatively, one can also use a '<code>\</code>' for escaping the delimiter each time it occurs within a string literal. 
        For instance:</p>
      <pre id="string-literal-example" class="example nohighlight" data-transform="updateExample">
      <!--
      @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
      @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
      @prefix <http://example.org/#> .

      :spiderman rdfs:label 
          '"Bitten" by a radioactive spider.' ,
          "\"Bitten\" by a radioactive spider." ,
          """'Bitten' by "what"?
      A radioactive spider!""" .
      -->
    </pre>

      <p>The escape symbol '<code>\</code>' (<span class="codepoint">U+005C</span>) may only appear in a
        string literal as part of an <a href="#escseq">escape sequence</a>. Other restrictions within string literals
        depend on the delimiter:</p>
      <ul>
        <li>Literals delimited by <code>'</code> may not contain the characters
          <code>'</code>, <code title="LINE FEED"><sub>LF</sub></code> (<span class="codepoint">U+000A</span>), or <code
            title="CARRIAGE RETURN"><sub>CR</sub></code> (<span class="codepoint">U+000D</span>).
        </li>
        <li>Literals delimited by <code>&quot;</code> may not contain the characters <code>&quot;</code>, <code
            title="LINE FEED"><sub>LF</sub></code>, or <code title="CARRIAGE RETURN"><sub>CR</sub></code>.
        </li>
        <li>Literals delimited by <code>'''</code> may not contain the sequence of characters <code>'''</code>.
        </li>
        <li>Literals delimited by <code>&quot;&quot;&quot;</code> may not contain the sequence of characters
          <code>&quot;&quot;&quot;</code>.
        </li>
      </ul>
      <!-- <pre class="example nohighlight">@prefix : &lt;http://example.org/vocab/&gt; .
          @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
          @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

          _:x rdfs:comment &quot;This is an example.&quot;^^xsd:string . # literal with XML Schema string datatype
          _:x rdfs:comment &quot;This is an example.&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt; . # same as above
          _:x rdfs:comment &quot;This is an example.&quot; .  # same again
          _:x rdfs:comment &quot;To jest przykład.&quot;@pl . # literal with a language tag
          _:x rdfs:comment 'Ceci est un exemple.'@fr . # literal delimited by single quote
          _:x rdfs:comment '''This # literal with embedded new lines
          is
          an example.''' .
          </pre> -->
    </section>
    <section id='bnodes'>
      <h3>Blank Nodes</h3>
      <p>When describing resources in RDF, you can run into the following situations:</p>
      <ul>
        <li>
          It is not worth minting a new <a>IRI</a> for the resource, as it is unlikely that other <a>N3 graphs</a>
          will refer to it.
        </li>
        <li>
          There likely already exists an <a>IRI</a> for the resource, and we don't want to do an extensive search to find out what it is.
        </li>
      </ul>
      <p>Instead, you can use <dfn>blank nodes</dfn> to talk about resources.
        They are existential variables; that is, they state the existence of a thing without identifying it.
        <a>Blank nodes</a> can be represented in several ways, as described below.
        For details, please refer to ([[[RDF11-CONCEPTS]]]).
      </p>
      <section id='bnodeids'>
        <h4>Blank node identifiers</h4>
        <p>A <a>blank node</a> can be represented by a <dfn data-cite="RDF11-CONCEPTS#dfn-blank-node-identifier">blank
            node identifier</dfn>, which is unique within the <a>N3 graph</a>, expressed as <code>_:someLabel</code>. 
            Then, we use this identifier within our <a>N3 graph</a> to describe the corresponding resource, same as with an <a>IRI</a>.
        <p>For instance, this <a data-cite="RDF11-PRIMER#section-blank-node">example</a> shows that the Mona Lisa
           has an unidentified tree in its background. We don't want to concretely identify this tree, but we do want to describe it &mdash; 
          such as the painting it is in, and the type of tree:
        <p>
        <pre id="mona-lisa-bnode-id" class="example nohighlight" data-transform="updateExample">
            <!--
            @prefix ex: <http://example.org/#> .
            @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

            ex:mona_lisa_painting ex:portrays _:someTree .
            _:someTree rdf:type ex:CypressTree .
            -->
          </pre>
        <p>In this example, we minted a <a>blank node identifier</a> <code>_:someTree</code> to represent the resource that
          we want to describe. Note that this identifier is only usable within our local <a>N3 graph</a> &mdash; 
          if you want other <a>N3 graphs</a> to describe it, you should represent it using an <a>IRI</a>.</p>
      </section>
      <section id='bnodeprplist'>
        <h4>Blank node property lists</h4>
        <p>Using a <a>blank node identifier</a> requires introducing a new identifier for each <a>blank node</a>.
          In many cases, however, a blank node occurs only once as an object, 
          and is then further described as a subject in other statements, such as in the <a href="#mona-lisa-bnode-id">prior example</a>.
          In those cases, a more convenient syntax can be used.</p>
          <p>
          The <a href="#address-bnode-prp-list-simplified">example below</a> shows a more elaborate example: 
          identifiers `_:a` and `_:t` are used as object in only one statement, 
          and are then described as subject in other statements. 
          Using the blank node property list syntax, these cases can be represented as follows:</p>
        
        <table class="ex">
          <tr>
            <th>Using blank node identifiers:</th>
            <th>Using blank node property lists:</th>
          </tr>
          <tr>
            <td>
              <pre class="example no-highlight" id="address-bnode-prp-list-simplified" data-transform="updateExample">
                <!--
                  @prefix ex: <http://example.org/#> .
  
                  ex:john ex:address _:a .
                  _:a ex:street "Evergreen Terrace" .
                  _:a ex:number 742 .
                  _:a ex:town _:t .
                  _:t ex:name "Springfield" .
                -->
              </pre>
            </td>
            <td>
              <pre class="example no-highlight" id="address-bnode-prp-list" data-transform="updateExample">
              <!--
                @prefix ex: <http://example.org/#> .

                ex:john ex:address [
                  ex:street "Evergreen Terrace" ;
                  ex:number 742 ;
                  ex:town [ ex:name "Springfield" ]
                ] .
              -->
            </pre>
            </td>
          </tr>
        </table>

        <p class="note">See also the <a href="#iriprplist">IRI property list</a> syntax.</p>

        <p>As mentioned, this syntax is useful for cases where a blank node occurs only once as an object. 
          In case the blank node occurs several times as an object, such as describing multiple people with the same address,
          one should use blank node identifiers. For instance:

            <pre class="example no-highlight" id="address-multiple-people" data-transform="updateExample">
              <!--
                @prefix ex: <http://example.org/#> .

                ex:john ex:address _:a .
                ex:sally ex:address _:a .
                _:a ex:street "Evergreen Terrace" .
                _:a ex:number 742 .
                _:a ex:town [ ex:name "Springfield" ] .
              -->
            </pre>
            <p>We can still use the blank node property list syntax for describing the town, 
              as this blank node still only occurs once as object.</p>
        </p>
      </section>

      <section id="bnode-use-cases">
        <h4>Blank node use cases</h4>
        <p>Below, we summarize typical use cases where <a>blank nodes</a> are used to describe resources.</p>
        <p><strong>Unknown resources</strong>: we might <a data-cite="RDF11-PRIMER#section-blank-node">want to state</a>
          that the Mona Lisa painting has in its background an unidentified tree, which we know to be a cypress tree. We
          could mint an <a>IRI</a> such as "mona-lisa-cypress-tree", but we feel that would be redundant &mdash; we
          simply want to describe the tree, such as the painting it is in, and the type of tree. We're not particularly
          interested in allowing other <a>N3 graphs</a> to refer to the tree. Moreover, there may already exist an
          <a>IRI</a> for that particular tree, and we don't want to mint another <a>IRI</a> to refer to the same tree
          (nor do we want to lookup this existing <a>IRI</a>).
        </p>
        <p><strong>Composite information</strong>: when describing composite pieces of information, such as street addresses,
          telephone numbers and dates, it is often unlikely that anyone outside this <a>N3 graph</a> would need to refer
          to this address or its pieces. 
          Hence, it would be redundant to mint an <a>IRI</a> just for the purpose of structuring this information.
          Instead, one can use a <a data-lt="blank node">blank node</a> to connect the
          "composed" pieces of information, e.g., the street address, to its composite values, e.g., street name, number,
          and city, as shown in <a href="#address-bnode-prp-list">this example</a>.</p>
        <p><strong>N-ary relations</strong>: <a>blank nodes</a> are a convenient way to represent <a
            href="#nary-binary-rel">n-ary relations in N3</a>.</p>
        <!--
            <pre class="example nohighlight">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

            _:doerthe foaf:knows _:dominik .
            _:dominik foaf:knows [ foaf:firstName &quot;William&quot; ].</pre>
            -->
      </section>
    </section>
    <section id='collections'>
      <h3>Collections</h3>
      <p>We often need to describe ordered collections of things, e.g., a book written by several authors, 
        listing the students in a course, or the software modules within a package. N3 provides a succinct <dfn
          data-lt="n3 collection|n3 list|list">collection</dfn> syntax to represent ordered collections of
        resources enclosed by <code>(</code> <code>)</code>. The contained resources are called <dfn
          data-lt="collection member">members</dfn>.</p>
      <p>For instance:</p>
      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix <http://example.org/#> .

          :description_logic_handbook a :Book ;
              :author ( :deborah :daniele :peter) .
          -->
        </pre>
      <p>This states that the value of the author property is the <em>collection resource</em>.</p>
      <p class="note"><strong>Any additional meaning is not given by the N3 semantics</strong>. 
        For instance, this example does not imply that each member (e.g.,
        <code>:deborah</code>) can be considered as a value of the author property &mdash; i.e., the author property
        does not "distribute" across the members. 
        For that matter, it is also not implied that the first member put the most effort into the book.
        Any additional meaning, such as each member being an author of the book, 
        and the ordering reflecting the authors' effort, would always be application-specific.<br />
      <br />
      In general, to implement such application-specific meanings, N3 rules could be used.
      Alternatively, one could use an <a href="#object-lists-example">object list</a> 
      to explicitly state that each of these resources are authors of the book: <br />
      &nbsp;&nbsp;&nbsp;&nbsp;`:description_logic_handbook :author :deborah, :daniele, :peter .`<br />
      However, since RDF (and thus N3) statements do not have an inherent order, this example loses meaning 
        as we no longer know who can be considered the "first" author.
      </p>

      <p class="note">To an extent, an N3 collection <a href="#semantics">is equivalent to</a> the more verbose <a
        data-cite="rdf11-mt#rdf-collections">RDF Collection vocabulary</a>.</p>
      
      <p>In N3, collections may occur as subjects, predicates or objects in a statement. For instance:</p>
      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix <http://example.org/#> .

          (:Fred :Wilma :Dino) :approved :resolution123 .
          -->
        </pre>
      <p>Or even:</p>
      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix <http://example.org/#> .

          (:Fred :Wilma :Dino) (:read :liked :approved) (:resolution1 :resolution2 :resolution3) .
          -->
        </pre>
      <p>As before: any meaning that goes beyond the fact that 3 <a>collection</a> resources are involved in this
        statement, would be application-specific.</p>
        <!-- &mdash; for instance, that the predicate
        <code>(:read :liked :approved)</code> means that the subject <a>collection</a> did all those things for all
        members in the object <a>collection</a>. -->
      <!--
          <pre class="example nohighlight">
          @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
          _:n3
            foaf:member (
              _:doerthe
              _:william
              _:dominik
            ).</pre>
              -->
    </section>
    <section id='quotedgraphs'>
      <h3>Quoted Graphs</h3>
      <p>
        It is often useful to attach metadata to groups of triples &mdash; 
        to give the provenance, context, or version of the information, our opinion on the matter, and so on. 
        We can use <a>quoted graphs</a> to quote RDF graphs, and then describe the <a>quoted graph</a> using <a>N3
          statements</a>. For instance:
      </p>
      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix dc: <http://purl.org/dc/terms/> .
          @prefix <http://example.org/#> .

          { :cervantes dc:wrote :moby_dick } :opinion :lie ;
            :retrievedFrom <http://lies_r_us.com> ;
            :retrievedAt "2020-07-12T09:01:33"^^xsd:dateTime .
          -->
        </pre>
      <p>
        Essentially, a <a>quoted graph</a> records of the occurrence of an RDF graph &mdash; i.e., a <em>quoting</em> or
        <em>citing</em> of the graph. Importantly, a <a>quoted graph</a> does not assert the contents of the RDF
        graph as being true (e.g., <code>:cervantes dc:wrote :moby_dick</code>). In fact, the <a>quoted graph</a> is <a
          href="#semantics">interpreted as a resource on its own</a>.
      </p>
      <p>As with <a>collections</a>, <a>quoted graphs</a> can be used in any position in an <a>N3 statement</a>.</p>
      <p>As they represent a <i>quoting</i> of RDF graphs, <a>quoted graphs</a> are not "referentially transparent". For
        instance:</p>
      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix <http://example.org/#> .

          :LoisLane :believes { :Superman :can :fly } .
          -->
        </pre>
      <p>This <a>N3 statement</a> states that Lois Lane believes that Superman can fly.
        Even if it is known that <code>:Superman</code> is the same as <code>:ClarkKent</code>, one cannot infer from
        this that Lois Lane believes that <code>:ClarkKent</code> can fly. 
        Indeed, this is an accurate depiction of Lois Lane's statement at the time &mdash; 
        as she did not know that Superman is Clark Kent at that point, 
        she would certainly not be saying that Clark Kent can fly.</p>

    </section>
    <section id='paths'>
      <h4>Resource Paths</h4>
      <p>Similar to <a data-cite="SPARQL11-QUERY#propertypaths">SPARQL property paths</a> [[SPARQL11-QUERY]], 
        N3 <dfn>resource paths</dfn> concisely express paths between resources, 
        when intermediary resources on the path are not relevant.</p>

        <p>A <a>resource path</a> starts from a subject resource, followed by one or more predicates;
          each predicate is separated by a <dfn>directional indicator</dfn> to follow the predicate either forward (`!`) or in reverse (`^`).
        For example, the following example describes the city of Joe's mother's office's address:</p>

        <pre class="example nohighlight" data-transform="updateExample">
            <!--
@prefix : <http://example.org/#> .

:joe!:hasMother!:hasOffice!:hasAddress :hasCity "Metropolis" .
            -->
          </pre>

        <p>In this example, the intermediary resources &mdash; Joe's mother, her office, and its address &mdash; 
          are not described or referenced further, so the more concise <a>resource path</a> syntax can be used.</p>

        <p>The expansion of this shorthand syntax uses blank nodes to express the path between the two resources.
          The example above is equivalent to the following (using blank node identifiers for clarity):</p>

        <pre class="example nohighlight" data-transform="updateExample">
            <!--
@prefix : <http://example.org/#> .

:joe :hasMother _:m . 
_:m :hasOffice _:o . 
_:o :hasAddress _:a . 
_:a :hasCity "Metropolis" .
            -->
          </pre>

        <p>In other words, each predicate in <a>resource path</a> is expanded into a statement,
        with as subject either the starting resource, or prior blank node object; and as object a newly minted blank node. </p>

        <p>Relations can also be followed in reverse using the reverse (`^`) indicator.
          The following example, starting from `joe`,  follows the `hasMother` predicate to Joe's mother, 
          and then follows the `hasMother` predicate in reverse (thus pointing to someone who has the same mother):</p>

        <pre class="example nohighlight" data-transform="updateExample">
            <!--
@prefix : <http://example.org/#> .

:joe!:hasMother^:hasMother a :Person .
            -->
          </pre>

        <p>This could equally well be represented by the more verbose:</p>

        <pre class="example nohighlight" data-transform="updateExample">
            <!--
@prefix : <http://example.org/#> .

:joe :hasMother _:m.
_:d :hasMother _:m.
_:d a :Person.
            -->
          </pre>

      <p class="note">In SPARQL, a property path is used in the
        <a data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</a> position to describe a string of relationships between
        a <a data-cite="RDF11-CONCEPTS#dfn-subject">subject</a> and an <a data-cite="RDF11-CONCEPTS#dfn-object">object</a> resource.
        In contrast, a N3 <a>resource path</a> is most often used in the <a data-cite="RDF11-CONCEPTS#dfn-subject">subject</a> or
        <a data-cite="RDF11-CONCEPTS#dfn-object">object</a> position.
        Using a <a>resource path</a> in the predicate position, although technically allowed, is often a mistake.
        For instance, the following N3 <a>resource path</a>: <br />
        &nbsp;&nbsp;&nbsp;&nbsp;`:joe :hasAddress!:hasCity "Metropolis" .`<br />
        Would lead to the following expansion:<br />
        &nbsp;&nbsp;&nbsp;&nbsp;`:joe _:bn_1 "Metropolis" .`<br />
        &nbsp;&nbsp;&nbsp;&nbsp;`:hasAddress :hasCity _:bn_1 .`<br />
        Which is likely not the intention of the author.
      </p>

    </section>

    <section id='variables'>
      <h3>Variables and Quantification</h3>

      <pre class="example" data-transform="updateExample">
          <!--
          Preformatted Text
          all
          whitespaces
          are important
          here
          -->
        </pre>
    </section>
    <section id='logimpl'>
      <h3>Logical Implications</h3>

      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix foaf: <http://xmlns.com/foaf/0.1/> .

          {
          _:doerthe foaf:knows _:dominik .
          }
          =>
          {
          _:dominik foaf:knows _:doerthe .
          } .
          -->
        </pre>
    </section>
    <section id='keywords'>
      <h4>Keywords and special symbols</h4>

      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix foaf: <http://xmlns.com/foaf/0.1/> .

          <http://example.org/#dt> a foaf:Person ;
              foaf:name "Dominik Tomaszuk" ;
              = <http://example.org/#dominik> .
          -->
        </pre>
    </section>
  </section>
  <section id='semantics'>
    <h2>Semantics</h2>
    <section id='terms'>
      <h3>Terms and Formulae</h3>
      <p>
        In order to formally define the semantics of <abbr title="Notation3">N3</abbr>, we first give a more formal
        definition
        of the basic language concepts introduced in the previous section. Here, we omit constructs like
        <a href="#polists">predicate and object lists</a>,
        or <a href="#bnodeprplist">blank node property lists</a> as these can be seen as syntactic sugar.
      </p>
      <p>
        All examples shown earlier as well as the examples in the remainder of this document follow <abbr
          title="Notation3">N3</abbr>-turtle syntax which is also the standard syntax for <abbr
          title="Notation3">N3</abbr>.
        It is however possible, to use alternative syntaxes as long as the translation to <abbr
          title="Notation3">N3</abbr> turtle syntax is clearly defined.
      </p>
      <p class="ednote">
        Maybe we put that statement earlier?
      </p>
      <p>
        <abbr title="Notation3">N3</abbr> is an extension of RDF.
        We use the following concepts from the [[[RDF11-CONCEPTS]]]: <a data-cite="RDF11-CONCEPTS#section-IRIs">IRI</a>,
        <a data-cite="RDF11-CONCEPTS#section-triples">RDF triple</a>, <a
          data-cite="RDF11-CONCEPTS#section-rdf-graph">RDF graph</a>, <a
          data-cite="RDF11-CONCEPTS#section-triples">subject</a>,
        <a data-cite="RDF11-CONCEPTS#section-triples">predicate</a>, <a
          data-cite="RDF11-CONCEPTS#section-triples">object</a>, <a data-cite="RDF11-CONCEPTS#dfn-rdf-source">RDF
          source</a>,
        <a data-cite="RDF11-CONCEPTS#dfn-node">node</a>, <a data-cite="RDF11-CONCEPTS#dfn-blank-node">blank node</a>, <a
          data-cite="RDF11-CONCEPTS#dfn-literal">literal</a>,
        <a data-cite="RDF11-CONCEPTS#graph-isomorphism">isomorphic</a>,
        and <a data-cite="RDF11-CONCEPTS#section-generalized-rdf">generalized RDF triples, graphs, and datasets</a>.
      </p>


      <p>
        We extend these definitions by introducing the following concepts:
      </p>
      <!--  <p>
          The set of <dfn>N3 symbols</dfn> consists of the set of <a>N3 triple elements</a> and the
          <a>universal variables</a> which are defined below.
        </p> -->
      <p>
        The set of <dfn data-lt="triple element|n3 triple element">N3 triple elements</dfn> consists of the disjoint
        sets of
        <a data-cite="RDF11-CONCEPTS#dfn-iri">IRIs</a>,
        <a data-cite="RDF11-CONCEPTS#dfn-blank-node">blank nodes</a>,
        <a data-cite="RDF11-CONCEPTS#dfn-literal">literals</a>,
        <a href="#dfn-universals">universal variables</a>,
        <a>lists</a>,
        and <a>quoted graphs</a>.
        The set of <a data-cite="RDF11-CONCEPTS#dfn-iri">IRIs</a> conatians the implication sign denoted by the
        <a>built-in</a> <code>log:implies</code>.
        This symbol indicates logical implication and MAY in N3-turtle syntax also be represented using the symbols
        <code>=&gt;</code>.
        The set of <a data-cite="RDF11-CONCEPTS#dfn-literal">literals</a> contains the two boolean literals
        <code>false</code> and <code>true</code>.
        The latter can also be written as <code>{}</code> in N3 turtle syntax.
      </p>
      <p>
        The set of <dfn data-lt="universals">universal variables</dfn> is an arbitrary set of symbols which is disjoint
        to all other <a>N3 triple elements</a>.
        In N3-turtle syntax, universal variables are represented by strings starting with a question mark
        <code>?</code>.
      </p>
      <p>
        <dfn>Lists</dfn> are ordered sets consisting of zero or more <a>N3 triple elements</a>.
        We call the list which has no elements the empty list. In N3-turtle syntax,
        we indicate lists by using round brackets <code>()</code>.
        The empty list in <abbr title="Notation3">N3</abbr> is equivalent to the empty list in RDF and can
        thus also be represented using <a href="https://www.w3.org/TR/rdf11-mt/#rdf-interpretations">rdf:nil</a>.
      </p>
      <p>
        <dfn data-lt="quoted graphs|cited formula">Quoted graphs</dfn> (sometimes also called cited formulae) are
        <a>N3 formulae</a> which are surrounded by quoting signs.
        In N3-turtle syntax, we denote these quoting signs as curly brackets <code>{}</code>.
      </p>
      <p>
        An <dfn>N3 triple</dfn> consists of the three components subject, predicate and object, each being an <a>N3
          triple element</a>.
      </p>
      <p>
        An <dfn data-lt="N3 formulae">N3 formula</dfn> is a set of <a>N3 triples</a>.
      </p>
      <p>Let <code>T</code> be the set of <a>N3 triple elements</a> and <code>dc:T&xrarr;T</code> a function defined as
        follows:</p>
      <ul>
        <li><code>dc(c)=dc(c<sub>1</sub>)&cup;...&cup;dc(c<sub>n</sub>)</code>, if
          <code>c=(c<sub>1</sub>... c<sub>n</sub>)</code> is a list,
        </li>
        <li><code>dc(c)={c} </code>else.</li>
      </ul>

      <p>For each <a>N3 triple</a> <code>t= s p o</code> we call the set <code>dc(t)=dc(s)&cup;dc(p)&cup;dc(o)</code>
        the <dfn data-lt="dir-comp">direct components</dfn> of <code>t</code>. For each <a>N3 formula</a> the set of
        its direct components is the union of the direct components of the triples it contains. </p>

      <p>Let <code>T</code> be the set of <a>N3 triple elements</a> and <code>F</code> the set of <a>N3 formula</a>. We
        define the function
        <code>nc:T&cup;F&xrarr;T</code> a function defined as follows:
      </p>
      <ul>
        <li><code>nc(e)=nc(e<sub>1</sub>)&cup;...&cup;nc(e<sub>n</sub>)</code>,
          if <code>e=e<sub>1</sub>... e<sub>n</sub></code> is an <a>N3 formula</a> and
          <code>e<sub>1</sub>)&cup;...&cup;nc(e<sub>n</sub></code> are <a>N3 triples</a>,
        </li>
        <li><code>nc(e)=nc(e<sub>1</sub>)&cup;nc(e<sub>2</sub>)&cup;nc(e<sub>3</sub>)</code>,
          if <code>e=e<sub>1</sub> c<sub>2</sub> e<sub>3</sub></code>
          is an <a>N3 triple</a>
          and <code>e<sub>1</sub>, c<sub>2</sub>, e<sub>3</sub></code>
          are <a>N3 triple elements</a>,</li>
        <li><code>nc(e)=nc(e<sub>1</sub>)&cup;...&cup;nc(e<sub>n</sub>)</code>,
          if <code>e=(e<sub>1</sub>... e<sub>n</sub>)</code> is a list,</li>
        <li><code>nc(e)=dc(e<sub>1</sub>)&cup; nc(e<sub>1</sub>)</code>,
          if <code>e={e<sub>1</sub>}</code> is a <a>cited formula</a>,</li>
        <li><code>nc(e)=&empty;</code> else.</li>
      </ul>

      <p>
        For each <a>N3 formula</a> <code>f</code>,
        we call <code>nc(f)</code> the set of <dfn>nested components</dfn>.
      </p>


      <p>
        We call an <a>N3 formula</a> <dfn>ground</dfn> if its direct and <a>nested components</a> do not contain
        <a>blank nodes</a> nor <a>universal variables</a>.
      </p>
      <p> We call an <a>N3 formula</a> <dfn>closed</dfn> if its direct and <a>nested components</a> do not contain
        <a>universal variables</a> and its <a>direct components</a> do not contain <a>blank nodes</a>.
      </p>
      <p class="EDNOTE">ReSpec complains because <a>ground</a> and <a>closed</a> are defined but not used.</p>
    </section>




    <section id='sinterpret'>
      <h3>Simple N3 interpretations</h3>

    </section>
    <section id='sneg'>
      <h3>Scoped Negation</h3>

    </section>
    <section id='builtins'>
      <h3>N3 Built-ins</h3>
      <p>N3 defines a core set of <dfn>built-ins</dfn> defined
        in a set of vocabularies with defined semantics
        for querying and manipulating <a>N3 documents</a>.
        Built-ins are denoted by a controlled IRI defined in
        one of the core namespaces:</p>
      <ul>
        <li><a href="crypto.html">Crypto</a> –
          <a href="http://www.w3.org/2000/10/swap/crypto#">http://www.w3.org/2000/10/swap/crypto#</a>,
        </li>
        <li><a href="list.html">List</a> –
          <a href="http://www.w3.org/2000/10/swap/list#">http://www.w3.org/2000/10/swap/list#</a>,
        </li>
        <li><a href="log.html">Log</a> –
          <a href="http://www.w3.org/2000/10/swap/log#">http://www.w3.org/2000/10/swap/log#</a>,
        </li>
        <li><a href="math.html">Math</a> –
          <a href="http://www.w3.org/2000/10/swap/math#">http://www.w3.org/2000/10/swap/math#</a>,
        </li>
        <li><a href="string.html">String</a> –
          <a href="http://www.w3.org/2000/10/swap/string#">http://www.w3.org/2000/10/swap/string#</a>, and
        </li>
        <li><a href="time.html">Time</a> –
          <a href="http://www.w3.org/2000/10/swap/time#">http://www.w3.org/2000/10/swap/time#</a>.
        </li>
      </ul>

    </section>
  </section>
  <section id='n3grammar'>
    <h2><abbr title="Extended Backus–Naur Form">EBNF</abbr> Grammar</h2>
    <p>The <a data-cite="TURTLE#sec-grammar-grammar">Turtle grammar</a> was used as the starting point for the <dfn>N3
        grammar</dfn>, which was subsequently adapted and extended with N3 constructs.</p>
    <p>The N3 Working Group made the following decisions that modify the <a>N3 grammar</a> as originally presented in
      [[N3]]:
    <ul>
      <li>
        Dropping the <code>@keywords</code> declaration. It is complex and difficult to explain. Also, when using the
        declaration, <a>N3 documents</a> look wholly different from when it is not being used, since it allows <a>local
          names</a> in the default namespace to be listed without the "<code>:</code>" symbol.
      </li>
      <li>
        Supporting all verb and boolean keywords (<code>is .. of</code>, <code>has</code>, <code>a</code>,
        <code>true</code>, <code>false</code>) both with and without "<code>@</code>" prefix. Turtle supports the
        <code>a</code> keyword, i.e., without an "<code>@</code>", but requires the symbol for the <code>@prefix</code>
        and <code>@base</code> declarations. The <a data-cite="N3#grammar">original N3 grammar</a> required the
        "<code>@</code>" prefix for all verb and boolean keywords. Hence, this decision was made for compatibility with
        Turtle as well as to avoid an unintuitive grammar, i.e., where some keywords have the "<code>@</code>" prefix
        and some don't.
      </li>
      <li>
        Representing an inverted property using the <code>&lt;components-</code> symbol. The <a
          data-cite="N3#grammar">original N3 grammar</a> allowed the inverting of a property by using the
        <code>@is .. @of</code> construct. But, this construct can be unintuitive when property names are more verbosely
        specified (e.g., <code>:hasFather</code>), leading to statements such as <code>?x @is :hasFather @of ?y</code>.
        The <code>is .. of</code> construct is still supported, but the above statement can now be represented as
        follows: <code>?x &lt;- :hasFather ?y</code>.
      </li>
    </ul>
    <section id='whitespace'>
      <h3>Whitespace</h3>
      <p>White space (<a href="#grammar-production-WS">WS production</a>) is used to separate terminals. The amount and
        type of white space (e.g., newline (`%0A`) or space (`%20`)) is only significant within terminals.</p>
      <p>We note that the <a href="#grammar-production-IRIREF">IRIREF</a> production only allows IRI-encoded white
        spaces.</p>
    </section>
    <section id='comments'>
      <h3>Comments</h3>
      <p>Comments are indicated using a "<code>#</code>" symbol outside an N3 terminal (e.g., <a
          href="#grammar-production-IRIREF">IRIREF</a>, <a href="#grammar-production-STRING">STRING</a>) and will
        continue until the end of the line (indicated by <code>\r</code>, <code>\n</code> or <code>\f</code>) or end of
        file, if there is no end of line marker.</p>
      <p>All recognized comment terminals will be skipped by the grammar (i.e., a resulting parser will not call
        listener or visitor code when encountering a comment.)</p>
    </section>
    <section id='escseq'>
      <h3>Escape sequences</h3>
      <p>There are three forms of escapes used in <a>N3 documents</a>:</p>
      <ul>
        <li>
          Escape sequences in string literals. These are characters that are traditionally escaped in strings:
          <table>
            <thead>
              <tr>
                <th>Escape sequence</th>
                <th>Unicode code point</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>'\t'</td>
                <td>U+0009</td>
              </tr>
              <tr>
                <td>'\b'</td>
                <td>U+0008</td>
              </tr>
              <tr>
                <td>'\n'</td>
                <td>U+000A</td>
              </tr>
              <tr>
                <td>'\r'</td>
                <td>U+000D</td>
              </tr>
              <tr>
                <td>'\f'</td>
                <td>U+000C</td>
              </tr>
              <tr>
                <td>'\&quot;'</td>
                <td>U+0022</td>
              </tr>
              <tr>
                <td>'\''</td>
                <td>U+0027</td>
              </tr>
              <tr>
                <td>'\\'</td>
                <td>U+005C</td>
              </tr>
            </tbody>
          </table>
          (see the <a href="#grammar-production-ECHAR">ECHAR</a> production)
        </li>
        <li>
          Numeric escape sequences. These represent Unicode code points:
          <table>
            <thead>
              <tr>
                <th>Escape sequence</th>
                <th>Unicode code point</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>'\u' <a href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a> <a
                    href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a></td>
                <td>A Unicode character in the range U+0000 to U+FFFF inclusive
                  corresponding to the value encoded by the four hexadecimal digits interpreted from most significant to
                  least significant digit.
                </td>
              </tr>
              <tr>
                <td>'\U' <a href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a> <a
                    href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a> <a
                    href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a> <a
                    href="#grammar-production-HEX">hex</a> <a href="#grammar-production-HEX">hex</a></td>
                <td>A Unicode character in the range U+0000 to U+10FFFF inclusive
                  corresponding to the value encoded by the eight hexadecimal digits interpreted from most significant
                  to least significant digit.
                </td>
              </tr>
            </tbody>
          </table>
          (see the <a href="#grammar-production-UCHAR">UCHAR</a> production)
        </li>
        <li>
          Escape sequences in <a>local names</a>. These escape the following reserved characters in the local name part
          of prefixed names: <code>_ ~ . - ! $ & \ ( ) * + , ; = / ? # @ %</code> (see the <a
            href="#grammar-production-PN_LOCAL_ESC">PN_LOCAL_ESC</a> production)
        </li>
      </ul>
    </section>
    <section id='irires'>
      <h3>IRI resolution</h3>
      <p> Relative IRIs are resolved with <a>base IRIs</a> using the algorithm in [[[RFC3986]]] [[RFC3986]]
        <a data-cite="RFC3986#section-5.2">Section 5.2 "Relative Resolution"</a>
        as supplemented by
        <a data-cite="RFC3987#section-6.5">Section 6.5</a>
        of [[[RFC3987]]] [[RFC3997]].
      </p>

      <p>The N3 <code>@base</code>
        or <code>BASE</code> directive can be used to
        define the <a>Base IRI</a>,
        per [[RFC3986]] <a data-cite="RFC3986#section-5.1.1">Section 5.1.1 "Base URI Embedded in Conent"</a>.
        Each `@base` or `BASE` directive sets a new In-Scope <a>Base IRI</a>,
        relative to the previous <a>base IRI</a>.</p>
    </section>
    <section id='pathres'>
      <h3>Resource path resolution</h3>
      <p><a>Resource paths</a> are resolved into zero or more <a>N3 triples</a>
        and a single <a>N3 triple element</a> which is used as the
        <a href="#grammar-production-expression">expression</a> value
        of the <a>path</a>.
      </p>
      <p>This section describes two logically equivalent algorithms
        for transforming a <a>path</a> into a set of <a>N3 triples</a>,
        and providing a resource to use as the
        effective
        <a data-cite="RDF11-CONCEPTS#dfn-subject">subject</a>,
        <a data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</a>, or
        <a data-cite="RDF11-CONCEPTS#dfn-object">object</a>
        in place of the original <a>path</a> expression.
      </p>

      <section class="algorithm" id="pathres-reverse">
        <h4>Right to Left Algorithm</h4>
        <p>The first algorithm describes a means
          of processing a <a href="#grammar-production-path">path</a>
          starting from the right hand side of the <a>path</a>.
          This is essentially the algorithm described
          in the <a data-cite="N3#path">Team Submission</a>.
          This is useful for an implementation based
          processing an Abstract Syntax Tree generated
          by a parser, or where the entire path
          is treated as a token and language-specific
          tools are used to process it further.</p>

        <p>Processing is performed by
          recursively processing the <a>path</a> |p|,
          in reverse, from the
          last <a>directional indicator</a> (`!`) or (`^`).
          The result of resolving |p| into an
          <a href="#grammar-production-expression">expression</a>
          and set of emitted <a>N3 triples</a>
          MUST be equivalent to using the following algorithm:
        </p>

        <ol>
          <li>If |p| matches the
            <a href="#grammar-production-pathItem">pathItem</a> production,
            then |p| can be reduced no further, return |p|
            as the result.
          </li>
          <li>Otherwise, separate the |p| into two components
            <var>p<sub>n-1</sub></var> and <var>pred<sub>n</sub></var>
            on the last occurrence of the
            <a>directional indicator</a> <var>dir<sub>n</sub></var>.
          </li>
          <li>Create <var>obj<sub>n</sub></var>
            by invoking this algorithm recursively
            using <var>p<sub>n-1</sub></var> for |p|.</li>
          <li>Create a novel <a>blank node</a>
            <var>B<sub>n</sub></var>.
          </li>
          <li>If <var>dir<sub>n</sub></var> is "`!`",
            emit a new <a>N3 triple</a>
            (<var>obj<sub>n</sub></var>
            <var>pred<sub>n</sub></var>
            <var>B<sub>n</sub></var>).
          </li>
          <li>Otherwise, <var>dir<sub>n</sub></var> is "`^`",
            emit a new <a>N3 triple</a>
            (<var>B<sub>n</sub></var>
            <var>pred<sub>n</sub></var>
            <var>obj<sub>n</sub></var>).
          </li>
          <li>Return <var>B<sub>n</sub></var> as the result.</li>
        </ol>

        <aside class="example" title="Processing :john!:father right to left">
          <p>Starting with the <a>path</a> |p| set to `:john!:father`:</p>
          <ul>
            <li>Step 1 does not apply, as `:john!:father` is not a
              <a href="#grammar-production-pathItem">pathItem</a>.
            </li>
            <li>Step 2 separates `:john!:father` into
              <var>p<sub>n-1</sub></var> `:john`,
              <var>pred<sub>n</sub></var> `:father`, and
              <var>dir<sub>n</sub></var> "`!`".
            </li>
            <li>Step 3 sets <var>obj<sub>n</sub></var>
              by calling the algorithm
              recursively using |p| `:john`.
              <ul>
                <li>Step 1 returns `:john` as it matches a
                  <a href="#grammar-production-pathItem">pathItem</a>.
                </li>
                <li><var>obj<sub>n</sub></var> is `:john`.</li>
              </ul>
            </li>
            <li>Step 4 creates <var>B<sub>n</sub></var>.</li>
            <li>Step 5 matches because <var>dir<sub>n</sub></var> is "`!`".
              The triple (`:john` `:father` <var>B<sub>n</sub></var>) is emitted.</li>
            <li>Step 7 returns <var>B<sub>n</sub></var>.</li>
          </ul>
        </aside>

        <aside class="example" title="Processing :john^:father!:mother right to left">
          <p>Starting with the <a>path</a> |p| set to `john^:father!:mother`:</p>
          <ul>
            <li>Step 1 does not apply, as `john^:father!:mother` is not a
              <a href="#grammar-production-pathItem">pathItem</a>.
            </li>
            <li>Step 2 separates `:john^:father!:mother` into
              <var>p<sub>n-1</sub></var> `:john^:father`,
              <var>pred<sub>n</sub></var> `:mother`, and
              <var>dir<sub>n</sub></var> "`!`".
            </li>
            <li>Step 3 creates <var>B<sub>n</sub></var>.</li>
            <li>Step 4 sets <var>obj<sub>n</sub></var> by calling the algorithm
              recursively using |p| `:john^:father`.
              <ul>
                <li>Step 1 does not apply, as `:john^:father` is not a
                  <a href="#grammar-production-pathItem">pathItem</a>.
                </li>
                <li>Step 2 separates `:john^:father` into
                  <var>p<sub>n-2</sub></var> `:john`,
                  <var>pred<sub>n-1</sub></var> `:father`, and
                  <var>dir<sub>n-1</sub></var> "`^`".
                </li>
                <li>Step 3 creates <var>B<sub>n-1</sub></var>.</li>
                <li>Step 4 sets <var>obj<sub>n-1</sub></var>
                  by calling the algorithm
                  recursively using |p| `:john`.
                  <ul>
                    <li>Step 1 returns `:john` as it matches a
                      <a href="#grammar-production-pathItem">pathItem</a>.
                    </li>
                    <li><var>obj<sub>n-1</sub></var> is `:john`.</li>
                  </ul>
                </li>
                <li>Step 6 matches because |dir| is "`^`".
                  The triple (<var>B<sub>n-1</sub></var> `:father` `:john`) is emitted.</li>
                <li>Step 7 returns <var>B<sub>n-1</sub></var>.</li>
                <li><var>obj<sub>n</sub></var> is
                  <var>B<sub>n-1</sub></var>.
                </li>
              </ul>
            </li>
            <li>Step 5 matches because |dir| is "`!`".
              The triple
              (<var>B<sub>n-1</sub></var> `:mother` <var>B<sub>n</sub></var>)
              is emitted.</li>
            <li>Step 7 returns <var>B<sub>n</sub></var>.</li>
          </ul>
        </aside>
      </section>

      <section class="algorithm" id="pathres-forward">
        <h4>Left to Right Algorithm</h4>
        <p>The second algorithm describes a means
          of processing a <a href="#grammar-production-path">path</a>
          starting from the left hand side of a <a>path</a>.
          This is useful for an implementation based
          on the parser productions described in the grammar
          that create events in this order (i.e., event-based).</p>

        <p>Processing is performed by
          iteratively processing the <a>path</a> <var>p</var>,
          in the forward direction,
          from the first <a>directional indicator</a> (`!`) or (`^`).
          The result of resolving <var>p</var> into an
          <a href="#grammar-production-expression">expression</a>
          and set of emitted <a>N3 triples</a>
          MUST be equivalent to using the following algorithm:
        </p>

        <p>Initialize |n| to `0` and
          <var>B<sub>0</sub></var> to the first
          <a href="#grammar-production-pathItem">pathItem</a> in |p|.
          Repeat the following algorithm steps until return.
        </p>

        <p class="note"><var>B<sub>0</sub></var> starts
          as the first <a href="#grammar-production-pathItem">pathItem</a> in |p|,
          but is updated to
          a novel <a>blank node</a> on subsequent iterations.</p>

        <ol>
          <li>If |n| equals the number of <a>directional indicators</a> in |p|,
            return <var>B<sub>n</sub></var>.</li>
          <li>Increment |n|,
            set <var>B<sub>n</sub></var> to a novel <a>blank node</a>,
            set <var>dir<sub>n</sub></var> to the next (<var>n<sub>th</sub></var>)
            <a>directional indicator</a> <var>dir<sub>n</sub></var>
            (if any),
            set <var>pred<sub>n</sub></var> to the next
            <a href="#grammar-production-pathItem">pathItem</a>
            (if any).
          </li>
          <li>If <var>dir<sub>n</sub></var> is "`!`",
            emit a new <a>N3 triple</a>
            (<var>B<sub>n-1</sub></var> <var>pred<sub>n</sub></var> <var>B<sub>n</sub></var>).</li>
          <li>Otherwise, if <var>dir<sub>n</sub></var> is "`^`",
            emit a new <a>N3 triple</a>
            (<var>B<sub>n</sub></var> <var>pred<sub>n</sub></var> <var>B<sub>n-1</sub></var>).</li>
        </ol>

        <aside class="example" title="Processing :john!:father left to right">
          <p>Starting with the <a>path</a> |p| set to `:john!:father`;
            |n| is `0` and
            <var>B<sub>0</sub></var> is `:john`:
          </p>
          <ul>
            <li>Step 1 does not apply, as |n| is `0`.</li>
            <li>Step 2 increments |n| to `1`,
              sets <var>B<sub>1</sub></var> to a novel <a>blank node</a>,
              <var>dir<sub>1</sub></var> to "`!`", and
              <var>pred<sub>1</sub></var> to `:father`.
            </li>
            <li>Step 3 emits
              (`:john` `:father` <var>B<sub>1</sub></var>),
              as <var>dir<sub>1</sub></var> is "`!`"</li>
            <li>Looping back to step 1, |n| is `1`:
              <ul>
                <li>Step 1 returns <var>B<sub>1</sub></var>
                  as |n| is `1`, which is the number of
                  directional indicators in `:john!:father`.</li>
              </ul>
            </li>
          </ul>
        </aside>

        <aside class="example" title="Processing :john^:father!:mother left to right">
          <p>Starting with the <a>path</a> |p| set to
            `:john^:father!:mother`;
            |n| is `0` and
            <var>B<sub>0</sub></var> is `:john`:
          </p>
          <ul>
            <li>Step 1 does not apply,
              as |n| is `0`.</li>
            <li>Step 2 increments |n| to `1`,
              sets <var>B<sub>1</sub></var> to a novel <a>blank node</a>,
              <var>dir<sub>1</sub></var> to "`^`", and
              <var>pred<sub>1</sub></var> to `:father`.
            </li>
            <li>Step 4 emits
              (<var>B<sub>1</sub></var> `:father` `:john`),
              as <var>dir<sub>1</sub></var> is "`^`"</li>
            <li>Looping back to step 1, |n| is `1`:
              <ul>
                <li>Step 1 does not apply, as |n| is `1`.</li>
                <li>Step 2 increments |n| to `2`,
                  sets <var>B<sub>2</sub></var> to a novel <a>blank node</a>,
                  <var>dir<sub>2</sub></var> to "`!`", and
                  <var>pred<sub>2</sub></var> to `:mother`.
                </li>
                <li>Step 3 emits
                  (<var>B<sub>1</sub></var> `:mother` <var>B<sub>2</sub></var>),
                  as <var>dir<sub>2</sub></var> is "`!`"</li>
                <li>Looping back to step 1, |n| is `2`:
                  <ul>
                    <li>Step 1 returns <var>B<sub>2</sub></var>
                      as |n| is `2`, which is the number of
                      directional indicators in `:john^:father!:mother`.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </aside>
      </section>
    </section>
    <section id='grammar'>
      <h3>Grammar</h3>
      <div data-include="../grammar/n3.html"></div>
      <p>A textual version of this grammar may be found <a href="n3.ebnf">here</a>.</p>
    </section>
  </section>
  <section class=informative>
    <h2>Relationship to Other Languages</h2>
    <section id="rel-n3-turtle">
      <h3>Turtle</h3>
      <p>N3 is a superset of [[[turtle]]], meaning that all valid Turtle documents will be valid in N3 as well. The
        inverse is not true, i.e., a valid <a>N3 document</a> will not always be valid in Turtle.</p>
      <p>The current <a>N3 grammar</a> started from the <a data-cite="TURTLE#sec-grammar">Turtle grammar</a> which was
        adapted and extended to be in line with the <a data-cite="N3#grammar">original N3 grammar</a>. Hence, many of
        the grammar productions will be much more similar to the Turtle grammar than the initial N3 grammar.</p>
      <p>Important differences with Turtle are the following:</p>
      <ul>
        <li>Literals are allowed at any s/p/o position (i.e., subject, predicate or object) in a statement. See the <a
            href="#grammar-production-pathItem">pathItem</a> production, which is (eventually) referenced by the
          "subject", "predicate" and "object" productions.</li>
        <li>N3 includes <a>quoted graphs</a> (i.e., between "<code>{</code>" and "<code>}</code>"), which are allowed
          in any s/p/o position in a statement. See the <a href="#grammar-production-pathItem">pathItem</a> production.
        </li>
        <li><dfn data-lt="quickvar">Quick-variables</dfn> (e.g., "<code>?x</code>"), which are allowed in any s/p/o
          position in a statement. See the <a href="#grammar-production-pathItem">pathItem</a> production.
          <span class="ednote">ReSpec complains becuse <a>quickvar</a> is defined but not used.</span>
        </li>
        <li>A path syntax, comparable to (but not quite as extensive as) the <a
            data-cite="sparql11-query#propertypaths">SPARQL 1.1 Property Path</a> syntax. See the <a
            href="#grammar-production-path">path</a> production.</li>
        <li>The possibility to invert the predicate within a statement. See the <a
            href="#grammar-production-predicate">predicate</a> production.</li>
        <li>An additional set of keywords, including "<code>is .. of</code>", "<code>has</code>", "<code>=</code>",
          "<code>=></code>", "<code>&lt;=</code>", in addition to Turtle's "<code>a</code>" keyword (among others). All
          keywords can be optionally preceded by "<code>@</code>", for consistency with the "<code>@prefix</code>" and
          "<code>@base"</code> keywords.</li>
      </ul>
    </section>
    <section id="rel-n3-sparql">
      <h3>SPARQL</h3>
      <p>The <abbr title="SPARQL Protocol and RDF Query Language">SPARQL</abbr> 1.1 Query Language (SPARQL)
        [[SPARQL11-QUERY]] uses a Turtle-style [[turtle]] syntax for its <a
          data-cite="sparql11-query#rTriplesBlock">TriplesBlock production</a>. Differences between Turtle and SPARQL
        are elaborated in the <a data-cite="turtle#sec-diff-sparql">Turtle specification</a>.</p>
      <p>Below, we indicate some important differences between this production and N3:</p>
      <ul>
        <li>
          Like N3, SPARQL permits literals as the subject of RDF triples, but, in contrast to N3, it does not allow
          literals as the predicate of RDF triples. Similarly,
          N3 allows for <a href="#bnodeprplist">blank node property lists</a> and <a>collections</a> in any position,
          whereas SPARQL only allows them in the subject or object position.
        </li>
        <li>
          Like N3, SPARQL permits variables in any part of the triple. But, in contrast to N3, SPARQL allows writing
          variables as both <code>?name</code> and <code>$name</code>, whereas N3 only allows <code>?name</code>.
        </li>
        <li>
          N3 allows <a href="#iris">prefix and base directives</a> anywhere outside of a triple. In SPARQL, they are
          only allowed in the <a data-cite="sparql11-query#rPrologue">Prologue</a> (i.e., at the start of the SPARQL
          query). However, in general, we also recommend listing prolog and base directives at the start of <a>N3
            documents</a>.
        </li>
        <li>
          In N3, most keywords (including <code>@prefix</code> and <code>@base</code> directives) are case sensitive,
          but most keywords in SPARQL are case-insensitive (aside from <code>a</code>). An exception in N3 are the
          <code>PREFIX</code> and <code>BASE</code> directives, which are derived from SPARQL and are case insensitive
          in N3 as well.
        </li>
        <li>
          The <a href="#paths">N3 path syntax</a> resembles the <a data-cite="sparql11-query#propertypaths">SPARQL 1.1
            Property Path</a> syntax, but there are important differences:
          <ul>
            <li>
              It is assumed that the <strong>path starts from a resource (<em>IR</em>) instead of a property
                (<em>IP</em>)</strong>. Hence, they are meant to be used in the subject and object positions, rather
              than the predicate position as is the case for SPARQL 1.1 property paths. This has important repercussions
              on how <a href="#pathres">paths are resolved</a>. Note that paths are unrelated to the inverted notation
              <code>^</code> for predicates (see the <a href="#grammar-production-predicate">predicate</a> production)
            </li>
            <li>
              Compared to SPARQL, N3 only supports the <em>SequencePath</em> and <em>InversePath</em> expressions, but
              with syntactic differences: the '<code>!</code>' symbol is used to separate path items, whereas the
              '<code>^</code>' symbol is used to indicate an inverse predicate.
            </li>
          </ul>
      </ul>
      <p>For more information, see the <a data-cite="sparql11-query#sparqlGrammar">SPARQL Grammar</a> section of
        [[[SPARQL11-QUERY]]].</p>
    </section>
    <section id="rel-n3-trig">
      <h3>TriG</h3>
      <p>[[[TRIG]]] is itself a superset of the Turtle syntax and includes a compact way to write RDF datasets, i.e.,
        sets of named graphs. In particular, TriG allows the specification of so-called graph statements, which are a
        pair of an <a>IRI</a> or blank node label and a group of triple statements surrounded by "<code>{</code>" and
        "<code>}</code>".</p>
      <p>For instance:</p>
      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          # This document contains a default graph and two named graphs.
          @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
          @prefix dc: <http://purl.org/dc/terms/> .
          @prefix foaf: <http://xmlns.com/foaf/0.1/> .

          # default graph
          <http://example.org/bob> dc:publisher "Bob" .
          <http://example.org/alice> dc:publisher "Alice" .
          <http://example.org/bob>
          {
          _:a foaf:name "Bob" .
          _:a foaf:mbox <mailto:bob@oldcorp.example.org> .
          _:a foaf:knows _:b .
          }
          <http://example.org/alice>
          {
          _:b foaf:name "Alice" .
          _:b foaf:mbox <mailto:alice@work.example.org> .
          }
          -->
        </pre>
      <p>N3 is not directly compatible with TriG as it does not support this graph statement notation. Nevertheless,
        since N3 supports <a>quoted graphs</a> as part of regular <a>N3 statements</a>,
        authors can utilize the N3 Named Graphs extension [<strong>X</strong>] for associating names or identifiers with
        <a>quoted graphs</a>. Although applications could easily introduce their own custom predicates for this
        purpose, we strongly recommend the use of this extension for interoperability purposes.
      </p>
      <p>The N3 Named Graphs extension [<strong>X</strong>] defines a set of <a>built-ins</a> (used as predicates) to
        associate names or identifiers with <a>quoted graphs</a>, which then become "named graphs". Moreover, each
        predicate has a well-defined semantics on how the named graph should be interpreted: as <a>quoted graphs</a>
        (the default N3 interpretation), a partitioning of triples within a dataset context, sets of triples with their
        own isolated contexts, or specifying relations between local and online graphs.</p>
    </section>
  </section>
  <section id='patterns' class=informative>
    <h3>Design Patterns</h3>
    <p>In this section, we present common patterns to solve often-occurring problems, for instance regarding data
      modeling, in N3.</p>
    <section id="naryrel">
      <h4>N-ary Relations</h4>
      <p>Until now, we only considered binary relations between entities and/or values. But, many types of relations are
        <em>ternary, quaternary, or, in general, n-ary in nature</em>, i.e., they have an arbitrary number of
        participants. Typical examples are purchase, employment, membership, .. relations.
      </p>
      <p>In other cases, we want to describe <em>properties of relations</em> &mdash; such as the provenance of a piece
        of information, or the probability of a diagnosis. But, in essence, this is the same problem as representing
        n-ary relations.</p>
      <p>There are several ways of representing n-ary relations in RDF &mdash; these are described in
        [[[swbp-n-aryRelations]]].</p>
      <p>Below, we illustrate options for representing n-ary relations in N3 in particular.</p>
      <section id="nary-binary-rel">
        <h4>Using sets of binary relations</h4>
        <p>In general, it is possible to convert any n-ary relation into an equivalent set of binary relations. This is
          a convenient solution, since we already know how to represent binary relations.</p>
        <p>First, we <em>create a resource</em> that represents the n-ary relation, and then <em>use a set of binary
            relations</em> to link each participant to this newly minted resource. Each binary relation is hereby given
          a meaningful name that <em>represents the role of the participant</em> in the n-ary relation.</p>
        <p>For instance, say we want to describe the <em>Purchase</em> relation between a buyer called "John", a
          purchased book called "Lenny the Lion", the amount paid for the book, and the seller:</p>
        <pre id="nary-book-relation" class="example nohighlight" data-transform="updateExample">
            <!--
            @prefix ex: <http://example.org/#> .
            ex:Purchase_1 a ex:Purchase ;
                ex:hasBuyer ex:John ;
                ex:hasObject ex:Lenny_The_Lion ;
                ex:hasAmount 15 ;
                ex:hasSeller <http://books.example.com> .
            -->

          </pre>
        <p class="note">Either you could mint a new <a>IRI</a> for representing the n-ary relation, or simply use a <a
            href="#bnodes">blank node</a>. E.g., in case other parties may want to refer to the n-ary relation from
          outside the N3 graph, one could choose to mint a new <a>IRI</a>;
          else, it will likely be more convenient to use a <a href="#bnodeprplist">blank node property list</a>.</p>
        <p>In other cases, things are more naturally described as <em>properties of relations</em>, rather than n-ary
          relations &mdash; for instance, the provenance of a piece of information, the trend of someone's body
          temperature and when the temperature was taken. Nevertheless, these can be represented in the same way as
          n-ary relation participants.</p>
        <p>We start from the same solution above, i.e., introducing a resource to represent the (in this case, binary)
          relation, and then linking the two participants to this resource. Subsequently, we use a set of binary
          relations to attach each descriptive property (e.g., diagnosis probability; temperature trend) to the relation
          resource.</p>
        <!-- <p>For instance, when describing a diagnosis (e.g., breast cancer) of someone (e.g., Christine), you may want to indicate the probability of the diagnosis, and the date at which the diagnosis was made:</p>
            <pre id="" class="example nohighlight">
            @prefix ex: &lt;http://example.org/#&gt; .
            @base &lt;http://example.org/#&gt; .
            @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
            ex:Christine
              a       :Person ;
              :hasDiagnosis _:Diagnosis_Relation_1 .

            _:Diagnosis_Relation_1
              :diagnosisProbability :HIGH ;
              :diagnosisValue :Breast_Tumor_Christine ;
              :diagnosisDate ""
            </pre> -->
        <p>For instance, when describing someone's (e.g., Christine) current temperature, you may want to indicate the
          absolute value (e.g., 40 degrees), a description of that value (e.g., elevated), the trend compared to the
          prior value (e.g., rising), and the time the temperature was taken:</p>
        <pre class="example nohighlight" data-transform="updateExample">
            <!--
            @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
            @base <http://example.org/#> .

            :Christine a :Person ;
                       :hasTemperature _:to1 .
            _:to1 :temperatureTrend :RISING ;
                  :temperatureValue 40 ;
                  :temperatureDescription :ELEVATED ;
                  :temperatureTime "2020-07-12T09:01:33"^^xsd:dateTime .
            -->
          </pre>
        <p>This is possible since we know that the relation resource (e.g., <code>to1</code>) represents the n-ary
          relation. Hence, any descriptive properties of the relation, in addition to participants in the relation, can
          simply be attached to the entity.</p>
        <p class="note">In this example, we made a statement with one of the participants (<code>:Christine</code>) as
          subject, and the relation resource (e.g., <code>_:to1</code>) as object. An alternative would have been to add
          <code>:Christine</code> as just another element of the n-ary relation, e.g., using a property
          <code>temperatureOf</code>. Our modeling choice here served to indicate that Christine is somehow the <a
            data-cite="swbp-n-aryRelations#useCase2">"owner" of the relationship</a>.
        </p>
        <!--
            (NOTE from a data modeling perspective, there would be a clear problem if the relation entity could have multiple "subjects" &mdash; e.g., in case it is being re-used to represent the same diagnosis for multiple patients. In that case, each of the patients'
            diagnosis probabilities would be linked to the same relation entity &mdash; and we lose the link that tells us which probability belongs to which patient. This can be seen as a kind of "fan trap".)
            -->
      </section>
      <section>
        <h4>Using collections</h4>
        <p>An even easier solution is to use a <a>collection</a> to keep all the participants of the n-ary relation. For
          instance: ...
          A clear advantage of this approach is that it is easier and much less verbose to write down.
          However, the roles each participant play in the n-ary relation are no longer explicated. For instance: ..
          What roles do X, Y and Z play in this relation? One could answer that question by having a tailored schema:
          ...
        </p>
      </section>
    </section>
    <section id="compoundliteral">
      <h4>Compound literal</h4>
      <p>This solution is inspired by a separate discussion of the RDF community on <em>Language Tagged Strings</em>.
        The essence of the discussion is to separate the string, as a simple data, from all the various
        characterizations that may be added to it. This design pattern uses the <code>rdf:CompoundLiteral</code> class,
        which is in the domain of <code>rdf:language</code> and <code>rdf:direction</code> to be used for describing RDF
        literal values containing base direction and a possible language tag to be associated with the string value of
        <code>rdf:value</code> on the same subject.
      </p>
      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix foaf: <http://xmlns.com/foaf/0.1/> .

          <http://example.org/#spiderman> foaf:name [
            rdf:value "الرجل العنكبوت",
            rdf:language "ar-eg",
            rdf:direction "rtl"
          ] .
          -->
        </pre>
    </section>
    <section id="reification">
      <h4>Graph quoted inside another graph</h4>
      <p>Reification in the RDF context means the expression of something in a language using the language so that it
        becomes treatable by the language. RDF graphs consist of RDF statements. If one wants to look objectively at an
        RDF graph and reason about it is using RDF tools, then it is useful to have a mechanism for describing RDF
        statements. N3 extends RDF to allow graphs themselves to be another form of literal node. A graph can be quoted
        inside another graph, as in the example:</p>
      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix : <http://example.org/>  .

          _:x :graph {
            <http://example.org/#spiderman> <http://xmlns.com/foaf/0.1/name> "Spiderman" .
          } .
          _:x :certainty 0.8 .
          -->
        </pre>
      <p>The above example can also be seen as <a data-cite="rdf11-mt#reification">RDF reification</a>:</p>
      <pre class="example nohighlight" data-transform="updateExample">
          <!--
          @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
          @prefix : <http://example.org/> .

          _:x a rdf:Statement ;
              rdf:subject <http://example.org/#spiderman> ;
              rdf:predicate <http://xmlns.com/foaf/0.1/name> ;
              rdf:object "Spiderman" ;
              :certainty 0.8 .
          -->
        </pre>
    </section>
  </section>
  <section id='in-html' class="appendix informative">
    <h2>Embedding N3 in HTML documents</h2>
    <p>HTML [[HTML5]] <code>script</code> element can be used to embed data blocks in documents. N3 can be easily
      embedded in <code>script</code> with the <code>type</code> attribute set to <code>text/n3</code>.</p>
    <p>Such content may be escaped as indicated below:</p>
    <ul>
      <li><code>&amp;amp;</code>: &amp; (ampersand, U+0026)</li>
      <li><code>&amp;lt;</code>: &lt; (less-than sign, U+003C)</li>
      <li><code>&amp;gt;</code>: &gt; (greater-than sign, U+003E)</li>
      <li><code>&amp;quot;</code>: &quot; (quotation mark, U+0022)</li>
      <li><code>&amp;apos;</code>: &apos; (apostrophe, U+0027)</li>
    </ul>
    <pre class="example nohighlight" data-transform="updateExample">
        <!--
        <script type="text/n3">
          @prefix : &lt;http://www.example.org/#&gt; .

          :green-goblin :enemyOf :spiderman .
        </script>
        -->
      </pre>
    <p>When embedded in XHTML N3 data blocks must be enclosed in CDATA sections. Those CDATA markers must be in Turtle
      comments. If the character sequence <code>]]&gt;</code> occurs in the document it must be escaped using strings
      escapes (<code>\u005d\u0054\u003e</code>). This will also make N3 safe in polyglot documents served as both
      <code>text/html</code> and <code>application/xhtml+xml</code>. Failing to use CDATA sections or escape
      <code>]]&gt;</code> may result in a non well-formed XML document.
    </p>
    <p class="ednote">Check this, I don't think that CDATA is required for XHTML any longer. See <a
        data-cite="JSON-LD11#embedding-json-ld-in-html-documents"></a>.</p>
    <pre class="example nohighlight" data-transform="updateExample">
        <!--
        <script type="text/n3">
          # <![CDATA[
          @prefix : <http://www.example.org/#> .

          :green-goblin :enemyOf :spiderman .
          # ]]>
        </script>
        -->
      </pre>
  </section>
  <section id='mime' class=appendix>
    <h2>Internet Media Type, File Extension and Macintosh File Type</h2>
    <p>This section has been submitted to the Internet Engineering Steering Group (IESG) for review, approval, and
      registration with IANA.</p>
    <dl>
      <dt>Contact:</dt>
      <dd>NAME</dd>
      <dt>Type name:</dt>
      <dd>text</dd>
      <dt>Subtype name:</dt>
      <dd>n3</dd>
      <dt>Optional parameters:</dt>
      <dd><code>charset</code> — this parameter is required when transferring non-ASCII data. If present, the value of
        <code>charset</code> is always <code>UTF-8</code>.
      </dd>
      <dt>Encoding considerations:</dt>
      <dd>The syntax of Notation3 is expressed over code points in Unicode [[UNICODE]]. The encoding is always UTF-8
        [[UTF-8]]. Unicode code points may also be expressed using an \uXXXX (U+0000 to U+FFFF) or \UXXXXXXXX syntax
        (for U+10000 onwards) where X is a hexadecimal digit [0-9A-Fa-f]</dd>
      <dt>Security considerations:</dt>
      <dd>Notation3 is a general-purpose assertion language; applications may evaluate given data to infer more
        assertions or to dereference <a>IRIs</a>, invoking the security considerations of the scheme for that
        <a>IRI</a>. Note in particular, the privacy issues in [[RFC3023]] section 10 for HTTP <a>IRIs</a>. Data obtained
        from an inaccurate or malicious data source may lead to inaccurate or misleading conclusions, as well as the
        dereferencing of unintended <a>IRIs</a>. Care must be taken to align the trust in consulted resources with the
        sensitivity of the intended use of the data; inferences of potential medical treatments would likely require
        different trust than inferences for trip planning. Notation3 is used to express arbitrary application data;
        security considerations will vary by domain of use. Security tools and protocols applicable to text (e.g. PGP
        encryption, MD5 sum validation, password-protected compression) may also be used on Notation3 documents.
        Security/privacy protocols must be imposed which reflect the sensitivity of the embedded information. Notation3
        can express data which is presented to the user, for example, RDF Schema labels. Application rendering strings
        retrieved from untrusted Notation3 documents must ensure that malignant strings may not be used to mislead the
        reader. The security considerations in the media type registration for XML ([[RFC3023]] section 10) provide
        additional guidance around the expression of arbitrary data and markup. Notation3 uses <a>IRIs</a> as term
        identifiers. Applications interpreting data expressed in Notation3 should address the security issues of
        Internationalized Resource Identifiers (<a>IRIs</a>) [[RFC3987]] Section 8, as well as Uniform Resource
        Identifier (URI): Generic Syntax [[RFC3986]] Section 7. Multiple <a>IRIs</a> may have the same appearance.
        Characters in different scripts may look similar (a Cyrillic "о" may appear similar to a Latin "o"). A character
        followed by combining characters may have the same visual representation as another character (LATIN SMALL
        LETTER E followed by COMBINING ACUTE ACCENT has the same visual representation as LATIN SMALL LETTER E WITH
        ACUTE). Any person or application that is writing or interpreting data in Notation3 must take care to use the
        <a>IRI</a> that matches the intended semantics, and avoid <a>IRIs</a> that make look similar. Further
        information about matching of similar characters can be found in Unicode Security Considerations
        [[UNICODE-SECURITY]] and Internationalized Resource Identifiers (<a>IRIs</a>) [[RFC3987]] Section 8.
      </dd>
      <dt>Interoperability considerations:</dt>
      <dd>Not Applicable</dd>
      <dt>Published specification:</dt>
      <dd>This specification.</dd>
      <dt>Applications which use this media type:</dt>
      <dd>Any programming environment that requires the exchange of directed graphs. Implementations of Notation3 have
        been created for JavaScript, Python, Java, and Prolog. It may be used by some web services and clients consuming
        their data.</dd>
      <dt>Additional information:</dt>
      <dt>Magic number(s):</dt>
      <dd>Notation3 documents may have the strings 'prefix' or 'base' (case independent) near the beginning of the
        document.</dd>
      <dt>File extension(s):</dt>
      <dd>.n3</dd>
      <dt>Macintosh file type code(s):</dt>
      <dd>TEXT</dd>
      <dt>Person &amp; email address to contact for further information:</dt>
      <dd>NAME &lt;EMAIL&gt;</dd>
      <dt>Intended usage:</dt>
      <dd>Common</dd>
      <dt>Restrictions on usage:</dt>
      <dd>None</dd>
      <dt>Author(s):</dt>
      <dd>Dörthe Arndt, William Van Woensel, Dominik Tomaszuk</dd>
      <dt>Change controller:</dt>
      <dd>W3C</dd>
    </dl>
  </section>
  <section id="changes-since-team-submission" class="appendix informative">
    <h2>Changes since the Team Submission</h2>
    <p>The following is a summary of changes made since the
      original Team Submission [[N3]]:</p>
    <ul>
      <li>Removed support for `@keywords` customizations.</li>
      <li>Removed `@a`, `@in`, and `@of` in favor of `a`, `in`, and `of`.</li>
      <li>Added `&lt;-` to represent an inverted property as a synonym of `is` <a
          href="#grammar-production-expression">expression</a> `of`.
      <li>Removed `@true` and `@false` in favor of `true` and `false`.</li>
      <li>Removed `@has`.</li>
      <li>Removed support for explicit <strong>N3 quantifiers</strong>
        (`@forSome` and `@forAll`).</li>
      <li>Removed whitespace from the
        <a href="#grammar-production-IRIREF">IRIREF</a> grammar terminal
        to be consistent with Turtle.
      </li>
    </ul>
    <p class="ednote">There are more accumulated changes to account for, to be sure.</p>
  </section>
  <section id='aknowledgements' class="appendix informative">
    <h2>Acknowledgements</h2>
    <p>The editors acknowledge valuable contributions from...</p>
  </section>
</body>

</html>